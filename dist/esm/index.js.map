{
  "version": 3,
  "sources": ["../../node_modules/fp-ts/lib/function.js", "../../node_modules/@most/prelude/src/array.ts", "../../node_modules/@most/prelude/src/function.ts", "../../node_modules/@most/scheduler/src/ScheduledTask.ts", "../../node_modules/@most/scheduler/src/RelativeScheduler.ts", "../../node_modules/@most/scheduler/src/task.ts", "../../node_modules/@most/scheduler/src/Scheduler.ts", "../../node_modules/@most/scheduler/src/Timeline.ts", "../../node_modules/@most/scheduler/src/ClockTimer.ts", "../../node_modules/@most/scheduler/src/clock.ts", "../../node_modules/@most/scheduler/src/schedule.ts", "../../node_modules/@most/scheduler/src/relative.ts", "../../node_modules/@most/scheduler/src/index.ts", "../../node_modules/@most/disposable/src/dispose.ts", "../../node_modules/@most/disposable/src/disposeNone.ts", "../../node_modules/@most/disposable/src/disposeOnce.ts", "../../node_modules/@most/disposable/src/disposeWith.ts", "../../node_modules/@most/disposable/src/disposeAll.ts", "../../node_modules/@most/disposable/src/tryDispose.ts", "../../node_modules/@most/core/src/fatalError.ts", "../../node_modules/@most/core/src/scheduler/PropagateTask.ts", "../../node_modules/@most/core/src/source/empty.ts", "../../node_modules/@most/core/src/source/never.ts", "../../node_modules/@most/core/src/source/at.ts", "../../node_modules/@most/core/src/source/now.ts", "../../node_modules/@most/core/src/source/periodic.ts", "../../node_modules/@most/core/src/source/newStream.ts", "../../node_modules/@most/core/src/disposable/SettableDisposable.ts", "../../node_modules/@most/core/src/runEffects.ts", "../../node_modules/@most/core/src/run.ts", "../../node_modules/@most/core/src/sink/RelativeSink.ts", "../../node_modules/@most/core/src/combinator/withLocalTime.ts", "../../node_modules/@most/core/src/sink/Pipe.ts", "../../node_modules/@most/core/src/combinator/loop.ts", "../../node_modules/@most/core/src/combinator/scan.ts", "../../node_modules/@most/core/src/combinator/continueWith.ts", "../../node_modules/@most/core/src/combinator/startWith.ts", "../../node_modules/@most/core/src/fusion/Filter.ts", "../../node_modules/@most/core/src/fusion/FilterMap.ts", "../../node_modules/@most/core/src/fusion/Map.ts", "../../node_modules/@most/core/src/combinator/transform.ts", "../../node_modules/@most/core/src/sink/IndexSink.ts", "../../node_modules/@most/core/src/invoke.ts", "../../node_modules/@most/core/src/combinator/combine.ts", "../../node_modules/@most/core/src/combinator/applicative.ts", "../../node_modules/@most/core/src/combinator/mergeConcurrently.ts", "../../node_modules/@most/core/src/combinator/chain.ts", "../../node_modules/@most/core/src/combinator/concatMap.ts", "../../node_modules/@most/core/src/combinator/merge.ts", "../../node_modules/@most/core/src/combinator/snapshot.ts", "../../node_modules/@most/core/src/combinator/slice/bounds.ts", "../../node_modules/@most/core/src/combinator/slice/index.ts", "../../node_modules/@most/core/src/combinator/zipItems.ts", "../../node_modules/@most/core/src/Queue.ts", "../../node_modules/@most/core/src/combinator/zip.ts", "../../node_modules/@most/core/src/combinator/switch.ts", "../../node_modules/@most/core/src/combinator/filter.ts", "../../node_modules/@most/core/src/combinator/timeslice.ts", "../../node_modules/@most/core/src/combinator/delay.ts", "../../node_modules/@most/core/src/combinator/limit.ts", "../../node_modules/@most/core/src/combinator/promises.ts", "../../node_modules/@most/core/src/sink/SafeSink.ts", "../../node_modules/@most/core/src/source/tryEvent.ts", "../../node_modules/@most/core/src/combinator/errors.ts", "../../node_modules/@most/core/src/combinator/multicast.ts", "../../node_modules/@most/core/src/index.ts", "../../node_modules/@typed/curry/src/curry1.ts", "../../node_modules/@typed/curry/src/curry2.ts", "../../node_modules/@typed/curry/src/curry3.ts", "../../node_modules/@typed/curry/src/curry4.ts", "../../node_modules/@typed/curry/src/curry5.ts", "../../node_modules/@typed/curry/src/curry.ts", "../../src/grid.ts", "../../src/cyclical.ts", "../../src/util.ts", "../../src/spout.ts"],
  "sourcesContent": ["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getEndomorphismMonoid = exports.not = exports.SK = exports.hole = exports.pipe = exports.untupled = exports.tupled = exports.absurd = exports.decrement = exports.increment = exports.tuple = exports.flow = exports.flip = exports.constVoid = exports.constUndefined = exports.constNull = exports.constFalse = exports.constTrue = exports.constant = exports.unsafeCoerce = exports.identity = exports.apply = exports.getRing = exports.getSemiring = exports.getMonoid = exports.getSemigroup = exports.getBooleanAlgebra = void 0;\n// -------------------------------------------------------------------------------------\n// instances\n// -------------------------------------------------------------------------------------\n/**\n * @category instances\n * @since 2.10.0\n */\nvar getBooleanAlgebra = function (B) { return function () { return ({\n    meet: function (x, y) { return function (a) { return B.meet(x(a), y(a)); }; },\n    join: function (x, y) { return function (a) { return B.join(x(a), y(a)); }; },\n    zero: function () { return B.zero; },\n    one: function () { return B.one; },\n    implies: function (x, y) { return function (a) { return B.implies(x(a), y(a)); }; },\n    not: function (x) { return function (a) { return B.not(x(a)); }; }\n}); }; };\nexports.getBooleanAlgebra = getBooleanAlgebra;\n/**\n * Unary functions form a semigroup as long as you can provide a semigroup for the codomain.\n *\n * @example\n * import { Predicate, getSemigroup } from 'fp-ts/function'\n * import * as B from 'fp-ts/boolean'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const S1 = getSemigroup(B.SemigroupAll)<number>()\n *\n * assert.deepStrictEqual(S1.concat(f, g)(1), true)\n * assert.deepStrictEqual(S1.concat(f, g)(3), false)\n *\n * const S2 = getSemigroup(B.SemigroupAny)<number>()\n *\n * assert.deepStrictEqual(S2.concat(f, g)(1), true)\n * assert.deepStrictEqual(S2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.10.0\n */\nvar getSemigroup = function (S) { return function () { return ({\n    concat: function (f, g) { return function (a) { return S.concat(f(a), g(a)); }; }\n}); }; };\nexports.getSemigroup = getSemigroup;\n/**\n * Unary functions form a monoid as long as you can provide a monoid for the codomain.\n *\n * @example\n * import { Predicate } from 'fp-ts/Predicate'\n * import { getMonoid } from 'fp-ts/function'\n * import * as B from 'fp-ts/boolean'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const M1 = getMonoid(B.MonoidAll)<number>()\n *\n * assert.deepStrictEqual(M1.concat(f, g)(1), true)\n * assert.deepStrictEqual(M1.concat(f, g)(3), false)\n *\n * const M2 = getMonoid(B.MonoidAny)<number>()\n *\n * assert.deepStrictEqual(M2.concat(f, g)(1), true)\n * assert.deepStrictEqual(M2.concat(f, g)(3), true)\n *\n * @category instances\n * @since 2.10.0\n */\nvar getMonoid = function (M) {\n    var getSemigroupM = exports.getSemigroup(M);\n    return function () { return ({\n        concat: getSemigroupM().concat,\n        empty: function () { return M.empty; }\n    }); };\n};\nexports.getMonoid = getMonoid;\n/**\n * @category instances\n * @since 2.10.0\n */\nvar getSemiring = function (S) { return ({\n    add: function (f, g) { return function (x) { return S.add(f(x), g(x)); }; },\n    zero: function () { return S.zero; },\n    mul: function (f, g) { return function (x) { return S.mul(f(x), g(x)); }; },\n    one: function () { return S.one; }\n}); };\nexports.getSemiring = getSemiring;\n/**\n * @category instances\n * @since 2.10.0\n */\nvar getRing = function (R) {\n    var S = exports.getSemiring(R);\n    return {\n        add: S.add,\n        mul: S.mul,\n        one: S.one,\n        zero: S.zero,\n        sub: function (f, g) { return function (x) { return R.sub(f(x), g(x)); }; }\n    };\n};\nexports.getRing = getRing;\n// -------------------------------------------------------------------------------------\n// utils\n// -------------------------------------------------------------------------------------\n/**\n * @since 2.11.0\n */\nvar apply = function (a) { return function (f) { return f(a); }; };\nexports.apply = apply;\n/**\n * @since 2.0.0\n */\nfunction identity(a) {\n    return a;\n}\nexports.identity = identity;\n/**\n * @since 2.0.0\n */\nexports.unsafeCoerce = identity;\n/**\n * @since 2.0.0\n */\nfunction constant(a) {\n    return function () { return a; };\n}\nexports.constant = constant;\n/**\n * A thunk that returns always `true`.\n *\n * @since 2.0.0\n */\nexports.constTrue = \n/*#__PURE__*/\nconstant(true);\n/**\n * A thunk that returns always `false`.\n *\n * @since 2.0.0\n */\nexports.constFalse = \n/*#__PURE__*/\nconstant(false);\n/**\n * A thunk that returns always `null`.\n *\n * @since 2.0.0\n */\nexports.constNull = \n/*#__PURE__*/\nconstant(null);\n/**\n * A thunk that returns always `undefined`.\n *\n * @since 2.0.0\n */\nexports.constUndefined = \n/*#__PURE__*/\nconstant(undefined);\n/**\n * A thunk that returns always `void`.\n *\n * @since 2.0.0\n */\nexports.constVoid = exports.constUndefined;\n/**\n * Flips the order of the arguments of a function of two arguments.\n *\n * @since 2.0.0\n */\nfunction flip(f) {\n    return function (b, a) { return f(a, b); };\n}\nexports.flip = flip;\nfunction flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {\n    switch (arguments.length) {\n        case 1:\n            return ab;\n        case 2:\n            return function () {\n                return bc(ab.apply(this, arguments));\n            };\n        case 3:\n            return function () {\n                return cd(bc(ab.apply(this, arguments)));\n            };\n        case 4:\n            return function () {\n                return de(cd(bc(ab.apply(this, arguments))));\n            };\n        case 5:\n            return function () {\n                return ef(de(cd(bc(ab.apply(this, arguments)))));\n            };\n        case 6:\n            return function () {\n                return fg(ef(de(cd(bc(ab.apply(this, arguments))))));\n            };\n        case 7:\n            return function () {\n                return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));\n            };\n        case 8:\n            return function () {\n                return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));\n            };\n        case 9:\n            return function () {\n                return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));\n            };\n    }\n    return;\n}\nexports.flow = flow;\n/**\n * @since 2.0.0\n */\nfunction tuple() {\n    var t = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        t[_i] = arguments[_i];\n    }\n    return t;\n}\nexports.tuple = tuple;\n/**\n * @since 2.0.0\n */\nfunction increment(n) {\n    return n + 1;\n}\nexports.increment = increment;\n/**\n * @since 2.0.0\n */\nfunction decrement(n) {\n    return n - 1;\n}\nexports.decrement = decrement;\n/**\n * @since 2.0.0\n */\nfunction absurd(_) {\n    throw new Error('Called `absurd` function which should be uncallable');\n}\nexports.absurd = absurd;\n/**\n * Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.\n *\n * @example\n * import { tupled } from 'fp-ts/function'\n *\n * const add = tupled((x: number, y: number): number => x + y)\n *\n * assert.strictEqual(add([1, 2]), 3)\n *\n * @since 2.4.0\n */\nfunction tupled(f) {\n    return function (a) { return f.apply(void 0, a); };\n}\nexports.tupled = tupled;\n/**\n * Inverse function of `tupled`\n *\n * @since 2.4.0\n */\nfunction untupled(f) {\n    return function () {\n        var a = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            a[_i] = arguments[_i];\n        }\n        return f(a);\n    };\n}\nexports.untupled = untupled;\nfunction pipe(a, ab, bc, cd, de, ef, fg, gh, hi, ij, jk, kl, lm, mn, no, op, pq, qr, rs, st) {\n    switch (arguments.length) {\n        case 1:\n            return a;\n        case 2:\n            return ab(a);\n        case 3:\n            return bc(ab(a));\n        case 4:\n            return cd(bc(ab(a)));\n        case 5:\n            return de(cd(bc(ab(a))));\n        case 6:\n            return ef(de(cd(bc(ab(a)))));\n        case 7:\n            return fg(ef(de(cd(bc(ab(a))))));\n        case 8:\n            return gh(fg(ef(de(cd(bc(ab(a)))))));\n        case 9:\n            return hi(gh(fg(ef(de(cd(bc(ab(a))))))));\n        case 10:\n            return ij(hi(gh(fg(ef(de(cd(bc(ab(a)))))))));\n        case 11:\n            return jk(ij(hi(gh(fg(ef(de(cd(bc(ab(a))))))))));\n        case 12:\n            return kl(jk(ij(hi(gh(fg(ef(de(cd(bc(ab(a)))))))))));\n        case 13:\n            return lm(kl(jk(ij(hi(gh(fg(ef(de(cd(bc(ab(a))))))))))));\n        case 14:\n            return mn(lm(kl(jk(ij(hi(gh(fg(ef(de(cd(bc(ab(a)))))))))))));\n        case 15:\n            return no(mn(lm(kl(jk(ij(hi(gh(fg(ef(de(cd(bc(ab(a))))))))))))));\n        case 16:\n            return op(no(mn(lm(kl(jk(ij(hi(gh(fg(ef(de(cd(bc(ab(a)))))))))))))));\n        case 17:\n            return pq(op(no(mn(lm(kl(jk(ij(hi(gh(fg(ef(de(cd(bc(ab(a))))))))))))))));\n        case 18:\n            return qr(pq(op(no(mn(lm(kl(jk(ij(hi(gh(fg(ef(de(cd(bc(ab(a)))))))))))))))));\n        case 19:\n            return rs(qr(pq(op(no(mn(lm(kl(jk(ij(hi(gh(fg(ef(de(cd(bc(ab(a))))))))))))))))));\n        case 20:\n            return st(rs(qr(pq(op(no(mn(lm(kl(jk(ij(hi(gh(fg(ef(de(cd(bc(ab(a)))))))))))))))))));\n    }\n    return;\n}\nexports.pipe = pipe;\n/**\n * Type hole simulation\n *\n * @since 2.7.0\n */\nexports.hole = absurd;\n/**\n * @since 2.11.0\n */\nvar SK = function (_, b) { return b; };\nexports.SK = SK;\n/**\n * Use `Predicate` module instead.\n *\n * @since 2.0.0\n * @deprecated\n */\nfunction not(predicate) {\n    return function (a) { return !predicate(a); };\n}\nexports.not = not;\n/**\n * Use `Endomorphism` module instead.\n *\n * @category instances\n * @since 2.10.0\n * @deprecated\n */\nvar getEndomorphismMonoid = function () { return ({\n    concat: function (first, second) { return flow(first, second); },\n    empty: identity\n}); };\nexports.getEndomorphismMonoid = getEndomorphismMonoid;\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n\n// Non-mutating array operations\n\n/**\n * a with x prepended\n */\nexport function cons <A>(x: A, a: ArrayLike<A>): A[] {\n  const l = a.length\n  const b = new Array(l + 1)\n  b[0] = x\n  for (let i = 0; i < l; ++i) {\n    b[i + 1] = a[i]\n  }\n  return b\n}\n\n/**\n * a with x appended\n */\nexport function append <A>(x: A, a: ArrayLike<A>): A[] {\n  const l = a.length\n  const b = new Array(l + 1)\n  for (let i = 0; i < l; ++i) {\n    b[i] = a[i]\n  }\n\n  b[l] = x\n  return b\n}\n\n/**\n * Concats two `ArrayLike`s\n */\nexport function concat <A>(a: ArrayLike<A>, b: ArrayLike<A>): A[] {\n  const al = a.length\n  const bl = b.length\n  const r = new Array(al + bl)\n  let i = 0\n  for (i = 0; i < al; i++) {\n    r[i] = a[i]\n  }\n  for (let j = 0; j < bl; j++) {\n    r[i++] = b[j]\n  }\n  return r\n}\n\n//\n/**\n * drop first n elements\n */\nexport function drop <A>(n: number, a: A[]): A[] {\n  if (n < 0) {\n    throw new TypeError('n must be >= 0')\n  }\n\n  const l = a.length\n  if (n === 0 || l === 0) {\n    return a\n  }\n\n  if (n >= l) {\n    return []\n  }\n\n  return unsafeDrop(n, a, l - n)\n}\n\n/**\n * Internal helper for drop\n */\nfunction unsafeDrop <A>(n: number, a: ArrayLike<A>, l: number): A[] {\n  const b = new Array(l)\n  for (let i = 0; i < l; ++i) {\n    b[i] = a[n + i]\n  }\n  return b\n}\n\n/**\n * drop head element\n */\nexport function tail <A>(a: A[]): A[] {\n  return drop(1, a)\n}\n\n/**\n * duplicate a (shallow duplication)\n */\nexport function copy <A>(a: ArrayLike<A>): A[] {\n  const l = a.length\n  const b = new Array(l)\n  for (let i = 0; i < l; ++i) {\n    b[i] = a[i]\n  }\n  return b\n}\n\n/**\n * transform each element with f\n */\nexport function map <A, B>(f: (a: A) => B, a: ArrayLike<A>): B[] {\n  const l = a.length\n  const b = new Array(l)\n  for (let i = 0; i < l; ++i) {\n    b[i] = f(a[i])\n  }\n  return b\n}\n\n/**\n * accumulate via left-fold\n */\nexport function reduce <A, B>(f: (a: A, b: B, i: number) => A, z: A, a: ArrayLike<B>): A {\n  let r = z\n  for (let i = 0, l = a.length; i < l; ++i) {\n    r = f(r, a[i], i)\n  }\n  return r\n}\n\n/**\n * replace element at index\n */\nexport function replace <A>(x: A, i: number, a: ArrayLike<A>): A[] {\n  if (i < 0) {\n    throw new TypeError('i must be >= 0')\n  }\n\n  const l = a.length\n  const b = new Array(l)\n  for (let j = 0; j < l; ++j) {\n    b[j] = i === j ? x : a[j]\n  }\n  return b\n}\n\n/**\n * remove element at index\n * @throws\n */\nexport function remove <A>(i: number, a: A[]): A[] {\n  if (i < 0) {\n    throw new TypeError('i must be >= 0')\n  }\n\n  const l = a.length\n  if (l === 0 || i >= l) { // exit early if index beyond end of array\n    return a\n  }\n\n  if (l === 1) { // exit early if index in bounds and length === 1\n    return []\n  }\n\n  return unsafeRemove(i, a, l - 1)\n}\n\n/**\n * Internal helper to remove element at index\n */\nfunction unsafeRemove <A>(i: number, a: ArrayLike<A>, l: number): A[] {\n  const b = new Array(l)\n  let j\n  for (j = 0; j < i; ++j) {\n    b[j] = a[j]\n  }\n  for (j = i; j < l; ++j) {\n    b[j] = a[j + 1]\n  }\n\n  return b\n}\n\n/**\n * remove all elements matching a predicate\n * @deprecated\n */\nexport function removeAll <A>(f: (a: A) => boolean, a: ArrayLike<A>): A[] {\n  const l = a.length\n  const b = new Array(l)\n  let j = 0\n  for (let x, i = 0; i < l; ++i) {\n    x = a[i]\n    if (!f(x)) {\n      b[j] = x\n      ++j\n    }\n  }\n\n  b.length = j\n  return b\n}\n\n/**\n * find index of x in a, from the left\n */\nexport function findIndex <A>(x: A, a: ArrayLike<A>): number {\n  for (let i = 0, l = a.length; i < l; ++i) {\n    if (x === a[i]) {\n      return i\n    }\n  }\n  return -1\n}\n\n/**\n * Return true iff x is array-like\n */\nexport function isArrayLike(x: any): x is ArrayLike<unknown> {\n  return x != null && typeof x.length === 'number' && typeof x !== 'function'\n}\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n\nexport const id = <A>(x: A): A => x\n\nexport const compose = <A, B, C>(f: (b: B) => C, g: (a: A) => B) => (x: A): C => f(g(x))\n\nexport const apply = <A, B>(f: (a: A) => B, x: A): B => f(x)\n\nexport interface Curried2<A, B, C> {\n  (): Curried2<A, B, C>\n  (a: A, b: B): C\n  (a: A): (b: B) => C\n}\n\nexport function curry2 <A, B, C>(f: (a: A, b: B) => C): Curried2<A, B, C> {\n  function curried(a: A, b: B): any {\n    switch (arguments.length) {\n      case 0: return curried\n      case 1: return (b: B) => f(a, b)\n      default: return f(a, b)\n    }\n  }\n  return curried as any\n}\n\nexport interface Curried3<A, B, C, D> {\n  (): Curried3<A, B, C, D>\n  (a: A): Curried2<B, C, D>\n  (a: A, b: B): (c: C) => D\n  (a: A, b: B, c: C): D\n}\n\nexport function curry3 <A, B, C, D>(f: (a: A, b: B, c: C) => D): Curried3<A, B, C, D> {\n  function curried(a: A, b: B, c: C): any {\n    switch (arguments.length) {\n      case 0: return curried\n      case 1: return curry2((b: B, c: C) => f(a, b, c))\n      case 2: return (c: C) => f(a, b, c)\n      default:return f(a, b, c)\n    }\n  }\n  return curried as any\n}\n\nexport interface Curried4<A, B, C, D, E> {\n  (): Curried4<A, B, C, D, E>\n  (a: A): Curried3<B, C, D, E>\n  (a: A, b: B): Curried2<C, D, E>\n  (a: A, b: B, c: C): (d: D) => E\n  (a: A, b: B, c: C, d: D): E\n}\n\nexport function curry4 <A, B, C, D, E>(f: (a: A, b: B, c: C, d: D) => E): Curried4<A, B, C, D, E> {\n  function curried(a: A, b: B, c: C, d: D): any {\n    switch (arguments.length) {\n      case 0: return curried\n      case 1: return curry3((b: B, c: C, d: D) => f(a, b, c, d))\n      case 2: return curry2((c: C, d: D) => f(a, b, c, d))\n      case 3: return (d: D) => f(a, b, c, d)\n      default:return f(a, b, c, d)\n    }\n  }\n  return curried as any\n}\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\nimport { ScheduledTask, Time, Task, Scheduler } from '@most/types'\n\nexport default class ScheduledTaskImpl implements ScheduledTask {\n  /**\n   * @mutable\n   */\n  time: Time;\n  readonly localOffset: Time;\n  readonly period: Time;\n  readonly task: Task;\n  readonly scheduler: Scheduler;\n  /**\n   * @mutable\n   */\n  active: boolean;\n\n  constructor(time: Time, localOffset: Time, period: Time, task: Task, scheduler: Scheduler) {\n    this.time = time\n    this.localOffset = localOffset\n    this.period = period\n    this.task = task\n    this.scheduler = scheduler\n    this.active = true\n  }\n\n  run(): void {\n    return this.task.run(this.time - this.localOffset)\n  }\n\n  error(e: Error): void {\n    return this.task.error(this.time - this.localOffset, e)\n  }\n\n  dispose(): void {\n    this.active = false\n    this.scheduler.cancel(this)\n    return this.task.dispose()\n  }\n}\n", "import { Scheduler, Time, Task, ScheduledTask } from '@most/types'\n\nexport default class RelativeScheduler implements Scheduler {\n  readonly origin: Time;\n  readonly scheduler: Scheduler;\n\n  constructor(origin: Time, scheduler: Scheduler) {\n    this.origin = origin\n    this.scheduler = scheduler\n  }\n\n  currentTime(): Time {\n    return this.scheduler.currentTime() - this.origin\n  }\n\n  scheduleTask(localOffset: Time, delay: Time, period: Time, task: Task): ScheduledTask {\n    return this.scheduler.scheduleTask(localOffset + this.origin, delay, period, task)\n  }\n\n  relative(origin: Time): Scheduler {\n    return new RelativeScheduler(origin + this.origin, this.scheduler)\n  }\n\n  cancel(task: ScheduledTask): void {\n    return this.scheduler.cancel(task)\n  }\n\n  cancelAll(f: (task: ScheduledTask) => boolean): void {\n    return this.scheduler.cancelAll(f)\n  }\n}\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nexport interface DeferrableTask<E, A> {\n  run(): A\n  error(e: Error): E\n}\n\nexport const defer = <E, A>(task: DeferrableTask<E, A>): Promise<E | A> =>\n  Promise.resolve(task).then(runTask)\n\nexport function runTask <E, A>(task: DeferrableTask<E, A>): E | A {\n  try {\n    return task.run()\n  } catch (e) {\n    return task.error(e)\n  }\n}\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nimport ScheduledTaskImpl from './ScheduledTask'\nimport RelativeScheduler from './RelativeScheduler'\nimport { runTask } from './task'\nimport { Scheduler, Time, Timer, Timeline, Task, ScheduledTask } from '@most/types'\n\nexport default class SchedulerImpl implements Scheduler {\n  private readonly timer: Timer\n  private readonly timeline: Timeline\n  private _timer: Time | null\n  private _nextArrival: Time;\n  private _runReadyTasksBound = () => this._runReadyTasks()\n\n  constructor(timer: Timer, timeline: Timeline) {\n    this.timer = timer\n    this.timeline = timeline\n\n    this._timer = null\n    this._nextArrival = Infinity\n  }\n\n  currentTime(): Time {\n    return this.timer.now()\n  }\n\n  scheduleTask(localOffset: Time, delay: Time, period: Time, task: Task): ScheduledTaskImpl {\n    const time = this.currentTime() + Math.max(0, delay)\n    const st = new ScheduledTaskImpl(time, localOffset, period, task, this)\n\n    this.timeline.add(st)\n    this._scheduleNextRun()\n    return st\n  }\n\n  relative(offset: Time): Scheduler {\n    return new RelativeScheduler(offset, this)\n  }\n\n  cancel(task: ScheduledTaskImpl): void {\n    task.active = false\n    if (this.timeline.remove(task)) {\n      this._reschedule()\n    }\n  }\n\n  // @deprecated\n  cancelAll(f: (task: ScheduledTask) => boolean): void {\n    this.timeline.removeAll(f)\n    this._reschedule()\n  }\n\n  _reschedule(): void {\n    if (this.timeline.isEmpty()) {\n      this._unschedule()\n    } else {\n      this._scheduleNextRun()\n    }\n  }\n\n  _unschedule(): void {\n    this.timer.clearTimer(this._timer)\n    this._timer = null\n  }\n\n  _scheduleNextRun(): void {\n    if (this.timeline.isEmpty()) {\n      return\n    }\n\n    const nextArrival = this.timeline.nextArrival()\n\n    if (this._timer === null) {\n      this._scheduleNextArrival(nextArrival)\n    } else if (nextArrival < this._nextArrival) {\n      this._unschedule()\n      this._scheduleNextArrival(nextArrival)\n    }\n  }\n\n  _scheduleNextArrival(nextArrival: Time): void {\n    this._nextArrival = nextArrival\n    const delay = Math.max(0, nextArrival - this.currentTime())\n    this._timer = this.timer.setTimer(this._runReadyTasksBound, delay)\n  }\n\n  _runReadyTasks(): void {\n    this._timer = null\n    this.timeline.runTasks(this.currentTime(), runTask)\n    this._scheduleNextRun()\n  }\n}\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nimport { findIndex, removeAll } from '@most/prelude'\nimport { Time, Timeline } from '@most/types'\nimport ScheduledTaskImpl from './ScheduledTask'\n\nexport default class TimelineImpl implements Timeline {\n  private tasks: TimeSlot[];\n\n  constructor() {\n    this.tasks = []\n  }\n\n  nextArrival(): number {\n    return this.isEmpty() ? Infinity : this.tasks[0].time\n  }\n\n  isEmpty(): boolean {\n    return this.tasks.length === 0\n  }\n\n  add(st: ScheduledTaskImpl): void {\n    insertByTime(st, this.tasks)\n  }\n\n  remove(st: ScheduledTaskImpl): boolean {\n    const i = binarySearch(getTime(st), this.tasks)\n\n    if (i >= 0 && i < this.tasks.length) {\n      const events = this.tasks[i].events\n      const at = findIndex(st, events)\n      if (at >= 0) {\n        events.splice(at, 1)\n        if (events.length === 0) {\n          this.tasks.splice(i, 1)\n        }\n        return true\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * @deprecated\n   */\n  removeAll(f: (task: ScheduledTaskImpl) => boolean): void {\n    for (let i = 0; i < this.tasks.length; ++i) {\n      removeAllFrom(f, this.tasks[i])\n    }\n  }\n\n  runTasks(t: Time, runTask: (task: ScheduledTaskImpl) => void): void {\n    const tasks = this.tasks\n    const l = tasks.length\n    let i = 0\n\n    while (i < l && tasks[i].time <= t) {\n      ++i\n    }\n\n    this.tasks = tasks.slice(i)\n\n    // Run all ready tasks\n    for (let j = 0; j < i; ++j) {\n      this.tasks = runReadyTasks(runTask, tasks[j].events, this.tasks)\n    }\n  }\n}\n\nfunction runReadyTasks(runTask: (task: ScheduledTaskImpl) => void, events: ArrayLike<ScheduledTaskImpl>, tasks: TimeSlot[]): TimeSlot[] {\n  for (let i = 0; i < events.length; ++i) {\n    const task = events[i]\n\n    if (task.active) {\n      runTask(task)\n\n      // Reschedule periodic repeating tasks\n      // Check active again, since a task may have canceled itself\n      if (task.period >= 0 && task.active) {\n        task.time = task.time + task.period\n        insertByTime(task, tasks)\n      }\n    }\n  }\n\n  return tasks\n}\n\nfunction insertByTime(task: ScheduledTaskImpl, timeslots: TimeSlot[]): void {\n  const l = timeslots.length\n  const time = getTime(task)\n\n  if (l === 0) {\n    timeslots.push(newTimeslot(time, [task]))\n    return\n  }\n\n  const i = binarySearch(time, timeslots)\n\n  if (i >= l) {\n    timeslots.push(newTimeslot(time, [task]))\n  } else {\n    insertAtTimeslot(task, timeslots, time, i)\n  }\n}\n\nfunction insertAtTimeslot(task: ScheduledTaskImpl, timeslots: TimeSlot[], time: Time, i: number): void {\n  const timeslot = timeslots[i]\n  if (time === timeslot.time) {\n    addEvent(task, timeslot.events)\n  } else {\n    timeslots.splice(i, 0, newTimeslot(time, [task]))\n  }\n}\n\nfunction addEvent(task: ScheduledTaskImpl, events: ScheduledTaskImpl[]): void {\n  if (events.length === 0 || task.time >= events[events.length - 1].time) {\n    events.push(task)\n  } else {\n    spliceEvent(task, events)\n  }\n}\n\nfunction spliceEvent(task: ScheduledTaskImpl, events: ScheduledTaskImpl[]): void {\n  for (let j = 0; j < events.length; j++) {\n    if (task.time < events[j].time) {\n      events.splice(j, 0, task)\n      break\n    }\n  }\n}\n\nfunction getTime(scheduledTask: ScheduledTaskImpl): Time {\n  return Math.floor(scheduledTask.time)\n}\n\n/**\n * @deprecated\n */\nfunction removeAllFrom(f: (task: ScheduledTaskImpl) => boolean, timeslot: TimeSlot): void {\n  timeslot.events = removeAll(f, timeslot.events)\n}\n\nfunction binarySearch(t: Time, sortedArray: ArrayLike<TimeSlot>): number {\n  let lo = 0\n  let hi = sortedArray.length\n  let mid, y\n\n  while (lo < hi) {\n    mid = Math.floor((lo + hi) / 2)\n    y = sortedArray[mid]\n\n    if (t === y.time) {\n      return mid\n    } else if (t < y.time) {\n      hi = mid\n    } else {\n      lo = mid + 1\n    }\n  }\n  return hi\n}\n\ninterface TimeSlot {\n  time: Time\n  events: ScheduledTaskImpl[]\n}\nconst newTimeslot = (t: Time, events: ScheduledTaskImpl[]): TimeSlot => ({ time: t, events: events })\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nimport { defer, DeferrableTask } from './task'\nimport { Clock, Time, Timer } from '@most/types'\n\n/* global setTimeout, clearTimeout */\n\nexport default class ClockTimer implements Timer {\n  private _clock: Clock;\n  constructor(clock: Clock) {\n    this._clock = clock\n  }\n\n  now(): Time {\n    return this._clock.now()\n  }\n\n  setTimer <A>(f: () => A, dt: Time): NodeJS.Timeout | Asap<A> {\n    return dt <= 0 ? runAsap(f) : setTimeout(f, dt)\n  }\n\n  clearTimer <A>(t: number | Asap<A>): void {\n    return t instanceof Asap ? t.cancel() : clearTimeout(t)\n  }\n}\n\nclass Asap<A> implements DeferrableTask<never, A | undefined> {\n  private readonly f: () => A;\n  /**\n   * @mutable\n   */\n  public active: boolean;\n\n  constructor(f: () => A) {\n    this.f = f\n    this.active = true\n  }\n\n  run(): A | undefined {\n    if (this.active) {\n      return this.f()\n    }\n  }\n\n  error(e: Error): never {\n    throw e\n  }\n\n  cancel(): void {\n    this.active = false\n  }\n}\n\nfunction runAsap <A>(f: () => A): Asap<A> {\n  const task = new Asap(f)\n  defer(task)\n  return task\n}\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\nimport { Clock, Time } from '@most/types'\n\n/* global performance, process */\n\nexport class RelativeClock implements Clock {\n  private readonly clock: Clock;\n  private readonly origin: Time;\n  constructor(clock: Clock, origin: Time) {\n    this.origin = origin\n    this.clock = clock\n  }\n\n  now(): Time {\n    return this.clock.now() - this.origin\n  }\n}\n\nexport class HRTimeClock implements Clock {\n  private readonly hrtime: (time: [number, number]) => [number, number];\n  private readonly origin: [Time, Time];\n  constructor(hrtime: (time: [number, number]) => [number, number], origin: [Time, Time]) {\n    this.origin = origin\n    this.hrtime = hrtime\n  }\n\n  now(): Time {\n    const hrt = this.hrtime(this.origin)\n    return (hrt[0] * 1e9 + hrt[1]) / 1e6\n  }\n}\n\nexport const clockRelativeTo = (clock: Clock): Clock =>\n  new RelativeClock(clock, clock.now())\n\nexport const newPerformanceClock = (): Clock =>\n  clockRelativeTo(performance)\n\n/**\n * @deprecated will be removed in 2.0.0\n * Date.now is not monotonic, and performance.now is ubiquitous:\n * @see https://caniuse.com/#search=performance.now\n */\nexport const newDateClock = (): Clock =>\n  clockRelativeTo(Date)\n\nexport const newHRTimeClock = (): Clock =>\n  new HRTimeClock(process.hrtime, process.hrtime())\n\nexport const newPlatformClock = (): Clock => {\n  if (typeof performance !== 'undefined' && typeof performance.now === 'function') {\n    return newPerformanceClock()\n  } else if (typeof process !== 'undefined' && typeof process.hrtime === 'function') {\n    return newHRTimeClock()\n  }\n\n  return newDateClock()\n}\n", "import { curry2, curry3 } from '@most/prelude'\nimport { Scheduler, Time, Task, ScheduledTask } from '@most/types'\n\n/**\n * Read the current time from the provided Scheduler\n */\nexport const currentTime = (scheduler: Scheduler): Time =>\n  scheduler.currentTime()\n\n/**\n * Schedule a task to run as soon as possible, but\n * not in the current call stack\n */\nexport const asap = curry2((task: Task, scheduler: Scheduler): ScheduledTask =>\n  scheduler.scheduleTask(0, 0, -1, task))\n\n/**\n * Schedule a task to run after a millisecond delay\n */\nexport const delay = curry3((delay: Time, task: Task, scheduler: Scheduler): ScheduledTask =>\n  scheduler.scheduleTask(0, delay, -1, task))\n\n/**\n * Schedule a task to run periodically, with the\n * first run starting asap\n */\nexport const periodic = curry3((period: Time, task: Task, scheduler: Scheduler): ScheduledTask =>\n  scheduler.scheduleTask(0, 0, period, task))\n\n/**\n * Cancel a scheduledTask\n */\nexport const cancelTask = (scheduledTask: ScheduledTask): void =>\n  scheduledTask.dispose()\n\n/**\n * Cancel all ScheduledTasks for which a predicate is true\n * @deprecated Will be removed in 2.0.0\n */\nexport const cancelAllTasks = curry2((predicate: (task: ScheduledTask) => boolean, scheduler: Scheduler): void => {\n  console.warn(`DEPRECATED cancelAllTasks to be removed in 2.0.0`)\n  return scheduler.cancelAll(predicate)\n})\n", "import RelativeScheduler from './RelativeScheduler'\nimport { curry2 } from '@most/prelude'\nimport { Time, Scheduler } from '@most/types'\n\nexport const schedulerRelativeTo = curry2((offset: Time, scheduler: Scheduler): Scheduler =>\n  new RelativeScheduler(offset, scheduler))\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nimport { curry2 } from '@most/prelude'\n\nimport Scheduler from './Scheduler'\nimport TimelineImpl from './Timeline'\nimport ClockTimer from './ClockTimer'\nimport { newPlatformClock } from './clock'\nimport { Clock, Timer, Timeline } from '@most/types'\n\nexport * from './clock'\nexport * from './schedule'\nexport * from './relative'\n\nexport const newScheduler = curry2((timer: Timer, timeline: Timeline): Scheduler => new Scheduler(timer, timeline))\n\nexport const newDefaultScheduler = (): Scheduler => new Scheduler(newDefaultTimer(), new TimelineImpl())\n\nexport const newDefaultTimer = (): Timer => new ClockTimer(newPlatformClock())\nexport const newClockTimer = (clock: Clock): Timer => new ClockTimer(clock)\n\nexport const newTimeline = (): Timeline => new TimelineImpl()\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\nimport { Disposable } from '@most/types'\n\nexport const dispose = (disposable: Disposable): void =>\n  disposable.dispose()\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\nimport { Disposable } from '@most/types'\n\nexport const disposeNone = (): Disposable => NONE\nconst NONE = new (class DisposeNone implements Disposable {\n  dispose(): void{}\n})()\n\nexport const isDisposeNone = (d: Disposable): boolean =>\n  d === NONE\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\nimport { Disposable } from '@most/types'\n\n/**\n * Wrap an existing disposable (which may not already have been once()d)\n * so that it will only dispose its underlying resource at most once.\n */\nexport const disposeOnce = (disposable: Disposable): Disposable =>\n  new DisposeOnce(disposable)\n\nclass DisposeOnce implements Disposable {\n  private disposed = false;\n  private disposable?: Disposable\n\n  constructor(disposable: Disposable) {\n    this.disposable = disposable\n  }\n\n  dispose(): void {\n    if (!this.disposed) {\n      this.disposed = true\n      if (this.disposable) {\n        this.disposable.dispose()\n        this.disposable = undefined\n      }\n    }\n  }\n}\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\nimport { disposeOnce } from './disposeOnce'\nimport { curry2 } from '@most/prelude'\nimport { Disposable } from '@most/types'\n\nexport interface DisposeWith {\n  (): DisposeWith\n  <R>(dispose: (resource: R) => void): (resource: R) => Disposable\n  <R>(dispose: (resource: R) => void, resource: R): Disposable\n}\n\n/**\n * Create a Disposable that will use the provided\n * dispose function to dispose the resource\n */\nexport const disposeWith: DisposeWith = curry2((dispose, resource) =>\n  disposeOnce(new DisposeWithImpl(dispose, resource)))\n\n/**\n * Disposable represents a resource that must be\n * disposed/released. It aggregates a function to dispose\n * the resource and a handle to a key/id/handle/reference\n * that identifies the resource\n */\nclass DisposeWithImpl<R> implements Disposable {\n  private _dispose: (resource: R) => void;\n  private _resource: R;\n\n  constructor(dispose: (resource: R) => void, resource: R) {\n    this._dispose = dispose\n    this._resource = resource\n  }\n\n  dispose(): void {\n    this._dispose(this._resource)\n  }\n}\n", "/** @license MIT License (c) copyright 2010 original author or authors */\nimport { append, reduce, curry2, concat } from '@most/prelude'\nimport { disposeNone, isDisposeNone } from './disposeNone'\nimport { Disposable } from '@most/types'\n\n/**\n * Aggregate a list of disposables into a DisposeAll\n */\nexport const disposeAll = (ds: ArrayLike<Disposable>): Disposable => {\n  const merged = reduce(merge, [], ds)\n  return merged.length === 0 ? disposeNone() : new DisposeAll(merged)\n}\n\n/**\n * Convenience to aggregate 2 disposables\n */\nexport const disposeBoth = curry2((d1: Disposable, d2: Disposable): Disposable =>\n  disposeAll([d1, d2]))\n\nconst merge = (ds: Disposable[], d: Disposable): Disposable[] =>\n  isDisposeNone(d) ? ds\n    : d instanceof DisposeAll ? concat(ds, d.disposables)\n      : append(d, ds)\n\nclass DisposeAll implements Disposable {\n  readonly disposables: ArrayLike<Disposable>\n\n  constructor(disposables: ArrayLike<Disposable>) {\n    this.disposables = disposables\n  }\n\n  dispose(): void {\n    throwIfErrors(disposeCollectErrors(this.disposables))\n  }\n}\n\n/**\n * Dispose all, safely collecting errors into an array\n */\nconst disposeCollectErrors = (disposables: ArrayLike<Disposable>): Error[] =>\n  reduce(appendIfError, [], disposables)\n\n/**\n * Call dispose and if throws, append thrown error to errors\n */\nconst appendIfError = (errors: Error[], d: Disposable): Error[] => {\n  try {\n    d.dispose()\n  } catch (e) {\n    errors.push(e)\n  }\n  return errors\n}\n\n/**\n * Throw DisposeAllError if errors is non-empty\n * @throws\n */\nconst throwIfErrors = (errors: ArrayLike<Error>): void => {\n  if (errors.length > 0) {\n    throw new DisposeAllError(`${errors.length} errors`, errors)\n  }\n}\n\nexport class DisposeAllError implements Error {\n  readonly name: string = 'DisposeAllError'\n  readonly stack?: string;\n  readonly message: string;\n  readonly errors: ArrayLike<Error>;\n\n  constructor(message: string, errors: ArrayLike<Error>) {\n    this.message = message\n    this.errors = errors\n    Error.call(this, message)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, DisposeAllError)\n    }\n    this.stack = `${this.stack}${formatErrorStacks(this.errors)}`\n  }\n}\nDisposeAllError.prototype = Object.create(Error.prototype)\n\nconst formatErrorStacks = (errors: ArrayLike<Error>): string =>\n  reduce(formatErrorStack, '', errors)\n\nconst formatErrorStack = (s: string, e: Error, i: number): string =>\n  s + `\\n[${(i + 1)}] ${e.stack}`\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\nimport { curry3 } from '@most/prelude'\nimport { Disposable, Sink, Time } from '@most/types'\n\n// Try to dispose the disposable.  If it throws, send\n// the error to sink.error with the provided Time value\nexport const tryDispose = curry3((t: Time, disposable: Disposable, sink: Sink<unknown>): void => {\n  try {\n    disposable.dispose()\n  } catch (e) {\n    sink.error(t, e)\n  }\n})\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nexport default function fatalError(e: unknown): void {\n  setTimeout(rethrow, 0, e)\n}\n\nfunction rethrow(e: unknown): never {\n  throw e\n}\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nimport fatal from '../fatalError'\nimport { Sink, Time, Task, Disposable } from '@most/types'\n\nexport type PropagateTaskRun<A> =\n  (time: number, value: A, sink: Sink<A>) => void\n\nexport const propagateTask = <A>(run: PropagateTaskRun<A>, value: A, sink: Sink<A>): PropagateTask => new PropagateRunEventTask(run, value, sink)\n\nexport const propagateEventTask = <A>(value: A, sink: Sink<A>): PropagateTask => new PropagateEventTask(value, sink)\n\nexport const propagateEndTask = (sink: Sink<unknown>): PropagateTask => new PropagateEndTask(sink)\n\nexport const propagateErrorTask = (value: Error, sink: Sink<Error>): PropagateTask => new PropagateErrorTask(value, sink)\n\nexport abstract class PropagateTask implements Task, Disposable {\n  active: boolean = true\n\n  constructor(protected readonly sink: Sink<unknown>) {}\n\n  protected abstract runIfActive(t: Time): void\n\n  dispose(): void {\n    this.active = false\n  }\n\n  run(t: Time): void {\n    if (!this.active) {\n      return\n    }\n    this.runIfActive(t)\n  }\n\n  error(t: Time, e: Error): void {\n    // TODO: Remove this check and just do this.sink.error(t, e)?\n    if (!this.active) {\n      return fatal(e)\n    }\n    this.sink.error(t, e)\n  }\n}\n\nclass PropagateRunEventTask<A> extends PropagateTask implements Task, Disposable {\n  constructor(private readonly runEvent: PropagateTaskRun<A>, private readonly value: A, sink: Sink<A>) {\n    super(sink)\n  }\n\n  protected runIfActive(t: Time): void {\n    this.runEvent(t, this.value, this.sink)\n  }\n}\n\nclass PropagateEventTask<A> extends PropagateTask implements Task, Disposable {\n  constructor(private readonly value: A, sink: Sink<A>) {\n    super(sink)\n  }\n\n  protected runIfActive(t: Time): void {\n    this.sink.event(t, this.value)\n  }\n}\n\nclass PropagateEndTask extends PropagateTask implements Task, Disposable {\n  protected runIfActive(t: Time): void {\n    this.sink.end(t)\n  }\n}\n\nclass PropagateErrorTask extends PropagateTask implements Task, Disposable {\n  constructor(private readonly value: Error, sink: Sink<never>) {\n    super(sink)\n  }\n\n  protected runIfActive(t: Time): void {\n    this.sink.error(t, this.value)\n  }\n}\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nimport { propagateEndTask } from '../scheduler/PropagateTask'\nimport { asap } from '@most/scheduler'\nimport { Stream, Sink, Scheduler, Disposable } from '@most/types'\n\nexport const empty = (): Stream<never> => EMPTY\n\nexport const isCanonicalEmpty = (stream: Stream<unknown>): boolean =>\n  stream === EMPTY\n\nexport const containsCanonicalEmpty = <A>(streams: ReadonlyArray<Stream<A>>): boolean =>\n  streams.some(isCanonicalEmpty)\n\nclass Empty implements Stream<never> {\n  run(sink: Sink<never>, scheduler: Scheduler): Disposable {\n    return asap(propagateEndTask(sink), scheduler)\n  }\n}\n\nconst EMPTY = new Empty()\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nimport { disposeNone } from '@most/disposable'\nimport { Disposable, Stream } from '@most/types'\n\nexport const never = (): Stream<never> => NEVER\n\nclass Never implements Stream<never> {\n  run(): Disposable {\n    return disposeNone()\n  }\n}\n\nconst NEVER = new Never()\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nimport { propagateTask } from '../scheduler/PropagateTask'\nimport { delay } from '@most/scheduler'\nimport { Time, Stream, Sink, Scheduler, Disposable } from '@most/types'\n\nexport const at = <A>(t: Time, x: A): Stream<A> => new At(t, x)\n\nclass At<A> implements Stream<A> {\n  private readonly time: Time;\n  private readonly value: A;\n\n  constructor(t: Time, x: A) {\n    this.time = t\n    this.value = x\n  }\n\n  run(sink: Sink<A>, scheduler: Scheduler): Disposable {\n    return delay(this.time, propagateTask(runAt, this.value, sink), scheduler)\n  }\n}\n\nfunction runAt<A>(t: Time, x: A, sink: Sink<A>): void {\n  sink.event(t, x)\n  sink.end(t)\n}\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nimport { at } from './at'\nimport { Stream } from '@most/types'\n\nexport const now = <A>(x: A): Stream<A> => at(0, x)\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nimport { propagateEventTask } from '../scheduler/PropagateTask'\nimport { periodic as schedulePeriodic } from '@most/scheduler'\nimport { Stream, Sink, Scheduler, Disposable } from '@most/types'\n\n/**\n * Create a stream of events that occur at a regular period\n * @param {Number} period periodicity of events\n * @returns {Stream} new stream of periodic events, the event value is undefined\n */\nexport const periodic = (period: number): Stream<void> =>\n  new Periodic(period)\n\nclass Periodic implements Stream<void> {\n  private readonly period: number;\n\n  constructor(period: number) {\n    this.period = period\n  }\n\n  run(sink: Sink<void>, scheduler: Scheduler): Disposable {\n    return schedulePeriodic(this.period, propagateEventTask(undefined, sink), scheduler)\n  }\n}\n", "import { Sink, Scheduler, Disposable, Stream } from '@most/types'\n\n/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nexport type RunStream<A> = (sink: Sink<A>, scheduler: Scheduler) => Disposable\n\nexport const newStream = <A>(run: RunStream<A>): Stream<A> => new StreamImpl(run)\n\nclass StreamImpl<A> {\n  readonly run: RunStream<A>;\n  constructor(run: RunStream<A>) {\n    this.run = run\n  }\n}\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\nimport { Disposable } from '@most/types'\n\nexport default class SettableDisposable implements Disposable {\n  private disposable?: Disposable;\n  private disposed: boolean;\n\n  constructor() {\n    this.disposable = undefined\n    this.disposed = false\n  }\n\n  setDisposable(disposable: Disposable): void {\n    if (this.disposable !== undefined) {\n      throw new Error('setDisposable called more than once')\n    }\n\n    this.disposable = disposable\n\n    if (this.disposed) {\n      disposable.dispose()\n    }\n  }\n\n  dispose(): void {\n    if (this.disposed) {\n      return\n    }\n\n    this.disposed = true\n\n    if (this.disposable !== undefined) {\n      this.disposable.dispose()\n    }\n  }\n}\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nimport { curry2 } from '@most/prelude'\nimport SettableDisposable from './disposable/SettableDisposable'\nimport { Stream, Scheduler, Time, Disposable, Sink } from '@most/types'\n\nexport interface RunEffects {\n  <A>(stream: Stream<A>, scheduler: Scheduler): Promise<void>\n  <A>(stream: Stream<A>): (scheduler: Scheduler) => Promise<void>\n}\n\nexport const runEffects: RunEffects = curry2((stream: Stream<unknown>, scheduler: Scheduler): Promise<void> =>\n  new Promise((resolve, reject) =>\n    runStream(stream, scheduler, resolve, reject)))\n\nfunction runStream <A>(stream: Stream<A>, scheduler: Scheduler, resolve: (a: A | undefined) => void, reject: (e: Error) => void): void {\n  const disposable = new SettableDisposable()\n  const observer = new RunEffectsSink(resolve, reject, disposable)\n\n  disposable.setDisposable(stream.run(observer, scheduler))\n}\n\nclass RunEffectsSink<A> implements Sink<A> {\n  private readonly _disposable: Disposable\n  private active: boolean;\n  private _error: (e: Error) => void\n  private _end: (x: A | undefined) => void\n\n  constructor(end: (x: A | undefined) => void, error: (e: Error) => void, disposable: Disposable) {\n    this._end = end\n    this._error = error\n    this._disposable = disposable\n    this.active = true\n  }\n\n  event(): void {}\n\n  end(): void {\n    if (!this.active) {\n      return\n    }\n    this.dispose(this._error, this._end, undefined)\n  }\n\n  error(_t: Time, e: Error): void {\n    this.dispose(this._error, this._error, e)\n  }\n\n  private dispose <X>(error: (e: Error) => void, end: (x: X) => void, x: X): void {\n    this.active = false\n    tryDispose(error, end, x, this._disposable)\n  }\n}\n\nfunction tryDispose <X>(error: (e: Error) => void, end: (x: X) => void, x: X, disposable: Disposable): void {\n  try {\n    disposable.dispose()\n  } catch (e) {\n    error(e)\n    return\n  }\n\n  end(x)\n}\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\nimport { Sink, Scheduler, Stream, Disposable } from '@most/types'\n\n/**\n * Run a Stream, sending all its events to the provided Sink.\n */\nexport const run = <A>(sink: Sink<A>, scheduler: Scheduler, stream: Stream<A>): Disposable =>\n  stream.run(sink, scheduler)\n", "import { Sink, Time } from '@most/types'\n\nexport default class RelativeSink<A> implements Sink<A> {\n  readonly offset: number\n  readonly sink: Sink<A>\n\n  constructor(offset: number, sink: Sink<A>) {\n    this.sink = sink\n    this.offset = offset\n  }\n\n  event(t: Time, x: A): void {\n    this.sink.event(t + this.offset, x)\n  }\n\n  error(t: Time, e: Error): void {\n    this.sink.error(t + this.offset, e)\n  }\n\n  end(t: Time): void {\n    this.sink.end(t + this.offset)\n  }\n}\n", "import RelativeSink from '../sink/RelativeSink'\nimport { schedulerRelativeTo } from '@most/scheduler'\nimport { Time, Stream, Sink, Scheduler, Disposable } from '@most/types'\n\n/**\n * Create a stream with its own local clock\n * This transforms time from the provided scheduler's clock to a stream-local\n * clock (which starts at 0), and then *back* to the scheduler's clock before\n * propagating events to sink.  In other words, upstream sources will see local times,\n * and downstream sinks will see non-local (original) times.\n */\nexport const withLocalTime = <A>(origin: Time, stream: Stream<A>): Stream<A> =>\n  new WithLocalTime(origin, stream)\n\nclass WithLocalTime<A> implements Stream<A> {\n  private readonly origin: Time;\n  private readonly source: Stream<A>;\n\n  constructor(origin: Time, source: Stream<A>) {\n    this.origin = origin\n    this.source = source\n  }\n\n  run(sink: Sink<A>, scheduler: Scheduler): Disposable {\n    return this.source.run(relativeSink(this.origin, sink), schedulerRelativeTo(this.origin, scheduler))\n  }\n}\n\n/**\n * Accumulate offsets instead of nesting RelativeSinks, which can happen\n * with higher-order stream and combinators like continueWith when they're\n * applied recursively.\n */\nexport const relativeSink = <A>(origin: Time, sink: Sink<A>): Sink<A> =>\n  sink instanceof RelativeSink\n    ? new RelativeSink(origin + sink.offset, sink.sink)\n    : new RelativeSink(origin, sink)\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\n/** @author Brian Cavalier */\nimport { Sink, Time } from '@most/types'\n\nexport default abstract class Pipe<A, B> implements Sink<A> {\n  protected readonly sink: Sink<B>\n\n  constructor(sink: Sink<B>) {\n    this.sink = sink\n  }\n\n  abstract event (t: Time, x: A): void\n\n  end(t: Time): void {\n    return this.sink.end(t)\n  }\n\n  error(t: Time, e: Error): void {\n    return this.sink.error(t, e)\n  }\n}\n", "/** @license MIT License (c) copyright 2010 original author or authors */\n\nimport Pipe from '../sink/Pipe'\nimport { empty, isCanonicalEmpty } from '../source/empty'\nimport { Stream, Sink, Scheduler, Time, Disposable } from '@most/types'\n\nexport interface SeedValue<S, V> { seed: S, value: V }\n\n/**\n * Generalized feedback loop. Call a stepper function for each event. The stepper\n * will be called with 2 params: the current seed and the an event value.  It must\n * return a new { seed, value } pair. The `seed` will be fed back into the next\n * invocation of stepper, and the `value` will be propagated as the event value.\n * @param stepper loop step function\n * @param seed initial seed value passed to first stepper call\n * @param stream event stream\n * @returns new stream whose values are the `value` field of the objects\n * returned by the stepper\n */\nexport const loop = <A, B, S>(stepper: (seed: S, a: A) => SeedValue<S, B>, seed: S, stream: Stream<A>): Stream<B> =>\n  isCanonicalEmpty(stream) ? empty()\n    : new Loop(stepper, seed, stream)\n\nclass Loop<A, B, S> implements Stream<B> {\n  private readonly step: (seed: S, a: A) => SeedValue<S, B>\n  private readonly seed: S;\n  private readonly source: Stream<A>\n\n  constructor(stepper: (seed: S, a: A) => SeedValue<S, B>, seed: S, source: Stream<A>) {\n    this.step = stepper\n    this.seed = seed\n    this.source = source\n  }\n\n  run(sink: Sink<B>, scheduler: Scheduler): Disposable {\n    return this.source.run(new LoopSink(this.step, this.seed, sink), scheduler)\n  }\n}\n\nclass LoopSink<A, B, S> extends Pipe<A, B> implements Sink<A> {\n  private readonly step: (seed: S, a: A) => SeedValue<S, B>;\n  private seed: S;\n  constructor(stepper: (seed: S, a: A) => SeedValue<S, B>, seed: S, sink: Sink<B>) {\n    super(sink)\n    this.step = stepper\n    this.seed = seed\n  }\n\n  event(t: Time, x: A): void {\n    const result = this.step(this.seed, x)\n    this.seed = result.seed\n    this.sink.event(t, result.value)\n  }\n}\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nimport Pipe from '../sink/Pipe'\nimport { disposeBoth } from '@most/disposable'\nimport { asap } from '@most/scheduler'\nimport { propagateEventTask } from '../scheduler/PropagateTask'\nimport { Stream, Sink, Scheduler, Time, Disposable } from '@most/types'\n\n/**\n * Create a stream containing successive reduce results of applying f to\n * the previous reduce result and the current stream item.\n * @param f reducer function\n * @param initial initial value\n * @param stream stream to scan\n * @returns new stream containing successive reduce results\n */\nexport const scan = <A, B>(f: (b: B, a: A) => B, initial: B, stream: Stream<A>): Stream<B> =>\n  new Scan(f, initial, stream)\n\nclass Scan<A, B> implements Stream<B> {\n  private readonly source: Stream<A>;\n  private readonly f: (b: B, a: A) => B;\n  private readonly value: B;\n\n  constructor(f: (b: B, a: A) => B, z: B, source: Stream<A>) {\n    this.source = source\n    this.f = f\n    this.value = z\n  }\n\n  run(sink: Sink<B>, scheduler: Scheduler): Disposable {\n    const d1 = asap(propagateEventTask(this.value, sink), scheduler)\n    const d2 = this.source.run(new ScanSink(this.f, this.value, sink), scheduler)\n    return disposeBoth(d1, d2)\n  }\n}\n\nclass ScanSink<A, B> extends Pipe<A, B> implements Sink<A> {\n  private readonly f: (b: B, a: A) => B\n  private value: B;\n\n  constructor(f: (b: B, a: A) => B, z: B, sink: Sink<B>) {\n    super(sink)\n    this.f = f\n    this.value = z\n  }\n\n  event(t: Time, x: A): void {\n    const f = this.f\n    this.value = f(this.value, x)\n    this.sink.event(t, this.value)\n  }\n}\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nimport Pipe from '../sink/Pipe'\nimport { run } from '../run'\nimport { withLocalTime } from './withLocalTime'\nimport { disposeOnce, tryDispose } from '@most/disposable'\nimport { Stream, Scheduler, Time, Disposable, Sink } from '@most/types'\n\nexport const continueWith = <A, B = A>(f: () => Stream<B>, stream: Stream<A>): Stream<A | B> =>\n  new ContinueWith(f, stream)\n\nclass ContinueWith<A, B> implements Stream<A | B> {\n  private readonly f: () => Stream<B>\n  private readonly source: Stream<A>\n\n  constructor(f: () => Stream<B>, source: Stream<A>) {\n    this.f = f\n    this.source = source\n  }\n\n  run(sink: Sink<A | B>, scheduler: Scheduler): Disposable {\n    return new ContinueWithSink(this.f, this.source, sink, scheduler)\n  }\n}\n\nclass ContinueWithSink<A, B> extends Pipe<A, A | B> implements Sink<A>, Disposable {\n  private readonly f: () => Stream<B>;\n  private readonly scheduler: Scheduler;\n  private active: boolean;\n  private disposable: Disposable\n\n  constructor(f: () => Stream<B>, source: Stream<A>, sink: Sink<A | B>, scheduler: Scheduler) {\n    super(sink)\n    this.f = f\n    this.scheduler = scheduler\n    this.active = true\n    this.disposable = disposeOnce(source.run(this, scheduler))\n  }\n\n  event(t: Time, x: A): void {\n    if (!this.active) {\n      return\n    }\n    this.sink.event(t, x)\n  }\n\n  end(t: Time): void {\n    if (!this.active) {\n      return\n    }\n\n    tryDispose(t, this.disposable, this.sink)\n\n    this.startNext(t, this.sink)\n  }\n\n  private startNext(t: Time, sink: Sink<A | B>): void {\n    try {\n      this.disposable = this.continue(this.f, t, sink)\n    } catch (e) {\n      sink.error(t, e)\n    }\n  }\n\n  private continue(f: () => Stream<B>, t: Time, sink: Sink<A | B>): Disposable {\n    return run(sink, this.scheduler, withLocalTime(t, f()))\n  }\n\n  dispose(): void {\n    this.active = false\n    return this.disposable.dispose()\n  }\n}\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nimport { now } from '../source/now'\nimport { continueWith } from './continueWith'\nimport { Stream } from '@most/types'\n\nexport const startWith = <A>(x: A, stream: Stream<A>): Stream<A> =>\n  continueWith(() => stream, now(x))\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nimport Pipe from '../sink/Pipe'\nimport { isCanonicalEmpty } from '../source/empty'\nimport { Stream, Sink, Scheduler, Time, Disposable } from '@most/types'\n\nexport default class Filter<A> implements Stream<A> {\n  readonly p: (a: A) => boolean\n  readonly source: Stream<A>\n\n  constructor(p: (a: A) => boolean, source: Stream<A>) {\n    this.p = p\n    this.source = source\n  }\n\n  run(sink: Sink<A>, scheduler: Scheduler): Disposable {\n    return this.source.run(new FilterSink(this.p, sink), scheduler)\n  }\n\n  /**\n   * Create a filtered source, fusing adjacent filter.filter if possible\n   * @param {function(x:*):boolean} p filtering predicate\n   * @param {{run:function}} source source to filter\n   * @returns {Filter} filtered source\n   */\n  static create <A>(p: (a: A) => boolean, source: Stream<A>): Stream<A> {\n    if (isCanonicalEmpty(source)) {\n      return source\n    }\n\n    if (source instanceof Filter) {\n      return new Filter(and(source.p, p), source.source)\n    }\n\n    return new Filter(p, source)\n  }\n}\n\nclass FilterSink<A> extends Pipe<A, A> implements Sink<A> {\n  private readonly p: (a: A) => boolean\n\n  constructor(p: (a: A) => boolean, sink: Sink<A>) {\n    super(sink)\n    this.p = p\n  }\n\n  event(t: Time, x: A): void {\n    const p = this.p\n    p(x) && this.sink.event(t, x)\n  }\n}\n\nconst and = <A>(p: (a: A) => boolean, q: (a: A) => boolean) => (x: A): boolean => p(x) && q(x)\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nimport Pipe from '../sink/Pipe'\nimport { Stream, Sink, Scheduler, Time, Disposable } from '@most/types'\n\nexport default class FilterMap<A, B> implements Stream<B> {\n  private readonly p: (a: A) => boolean;\n  private readonly f: (a: A) => B;\n  private readonly source: Stream<A>;\n\n  constructor(p: (a: A) => boolean, f: (a: A) => B, source: Stream<A>) {\n    this.p = p\n    this.f = f\n    this.source = source\n  }\n\n  run(sink: Sink<B>, scheduler: Scheduler): Disposable {\n    return this.source.run(new FilterMapSink(this.p, this.f, sink), scheduler)\n  }\n}\n\nclass FilterMapSink<A, B> extends Pipe<A, B> implements Sink<A> {\n  private readonly p: (a: A) => boolean;\n  private readonly f: (a: A) => B;\n\n  constructor(p: (a: A) => boolean, f: (a: A) => B, sink: Sink<B>) {\n    super(sink)\n    this.p = p\n    this.f = f\n  }\n\n  event(t: Time, x: A): void {\n    const f = this.f\n    const p = this.p\n    p(x) && this.sink.event(t, f(x))\n  }\n}\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nimport Pipe from '../sink/Pipe'\nimport Filter from './Filter'\nimport FilterMap from './FilterMap'\nimport { compose } from '@most/prelude'\nimport { isCanonicalEmpty, empty } from '../source/empty'\nimport { Stream, Sink, Scheduler, Time, Disposable } from '@most/types'\n\nexport default class Map<A, B> implements Stream<B> {\n  readonly f: (a: A) => B;\n  readonly source: Stream<A>;\n\n  constructor(f: (a: A) => B, source: Stream<A>) {\n    this.f = f\n    this.source = source\n  }\n\n  run(sink: Sink<B>, scheduler: Scheduler): Disposable {\n    return this.source.run(new MapSink(this.f, sink), scheduler)\n  }\n\n  /**\n   * Create a mapped source, fusing adjacent map.map, filter.map,\n   * and filter.map.map if possible\n   * @param {function(*):*} f mapping function\n   * @param {{run:function}} source source to map\n   * @returns {Map|FilterMap} mapped source, possibly fused\n   */\n  static create <A, B>(f: (a: A) => B, source: Stream<A>): Stream<B> {\n    if (isCanonicalEmpty(source)) {\n      return empty()\n    }\n\n    if (source instanceof Map) {\n      return new Map(compose(f, source.f), source.source)\n    }\n\n    if (source instanceof Filter) {\n      return new FilterMap(source.p, f, source.source)\n    }\n\n    return new Map(f, source)\n  }\n}\n\nclass MapSink<A, B> extends Pipe<A, B> implements Sink<A> {\n  private readonly f: (a: A) => B;\n\n  constructor(f: (a: A) => B, sink: Sink<B>) {\n    super(sink)\n    this.f = f\n  }\n\n  event(t: Time, x: A): void {\n    const f = this.f\n    this.sink.event(t, f(x))\n  }\n}\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nimport Map from '../fusion/Map'\nimport Pipe from '../sink/Pipe'\nimport { Stream, Sink, Scheduler, Time, Disposable } from '@most/types'\n\n/**\n * Transform each value in the stream by applying f to each\n * @param f mapping function\n * @param stream stream to map\n * @returns stream containing items transformed by f\n */\nexport const map = <A, B>(f: (a: A) => B, stream: Stream<A>): Stream<B> =>\n  Map.create(f, stream)\n\n/**\n* Replace each value in the stream with x\n* @param x\n* @param stream\n* @returns stream containing items replaced with x\n*/\nexport const constant = <A, B>(x: B, stream: Stream<A>): Stream<B> =>\n  map(() => x, stream)\n\n/**\n* Perform a side effect for each item in the stream\n* @param f side effect to execute for each item. The return value will be discarded.\n* @param stream stream to tap\n* @returns new stream containing the same items as this stream\n*/\nexport const tap = <A>(f: (a: A) => unknown, stream: Stream<A>): Stream<A> =>\n  new Tap(f, stream)\n\nclass Tap<A> implements Stream<A> {\n  private readonly f: (a: A) => unknown;\n  private readonly source: Stream<A>;\n\n  constructor(f: (a: A) => unknown, source: Stream<A>) {\n    this.source = source\n    this.f = f\n  }\n\n  run(sink: Sink<A>, scheduler: Scheduler): Disposable {\n    return this.source.run(new TapSink(this.f, sink), scheduler)\n  }\n}\n\nclass TapSink<A> extends Pipe<A, A> implements Sink<A> {\n  private readonly f: (a: A) => unknown;\n\n  constructor(f: (a: A) => unknown, sink: Sink<A>) {\n    super(sink)\n    this.f = f\n  }\n\n  event(t: Time, x: A): void {\n    const f = this.f\n    f(x)\n    this.sink.event(t, x)\n  }\n}\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nimport Pipe from './Pipe'\nimport { Time, Sink } from '@most/types'\n\nexport interface IndexedValue<A> {\n  readonly index: number\n  readonly value: A\n  readonly active: boolean\n}\n\nexport class IndexSink<A> extends Pipe<A, IndexedValue<A | undefined>> implements Sink<A> {\n  readonly index: number\n  active: boolean\n  value: A | undefined\n\n  constructor(i: number, sink: Sink<IndexedValue<A | undefined>>) {\n    super(sink)\n    this.index = i\n    this.active = true\n    this.value = undefined\n  }\n\n  event(t: Time, x: A): void {\n    if (!this.active) {\n      return\n    }\n    this.value = x\n    this.sink.event(t, this)\n  }\n\n  end(t: Time): void {\n    if (!this.active) {\n      return\n    }\n    this.active = false\n    this.sink.event(t, this)\n  }\n}\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n/**\n * TODO: find a better way (without `any`)\n */\nexport default function invoke <F extends(...args: any[]) => any>(f: F, args: Parameters<F>): ReturnType<F> {\n  /* eslint complexity: [2,7] */\n  switch (args.length) {\n    case 0: return f()\n    case 1: return f(args[0])\n    case 2: return f(args[0], args[1])\n    case 3: return f(args[0], args[1], args[2])\n    case 4: return f(args[0], args[1], args[2], args[3])\n    case 5: return f(args[0], args[1], args[2], args[3], args[4])\n    default:\n      return f.apply(undefined, args)\n  }\n}\n", "/** @license MIT License (c) copyright 2010 original author or authors */\n\nimport { map } from './transform'\nimport { empty, containsCanonicalEmpty } from '../source/empty'\nimport Pipe from '../sink/Pipe'\nimport { IndexSink, IndexedValue } from '../sink/IndexSink'\nimport { disposeAll, tryDispose } from '@most/disposable'\nimport invoke from '../invoke'\nimport { Stream, Sink, Scheduler, Disposable, Time } from '@most/types'\nimport { ToStreamsArray } from './variadic'\n\n/**\n * Combine latest events from two streams\n * @param f function to combine most recent events\n * @param stream1\n * @param stream2\n * @returns stream containing the result of applying f to the most recent\n *  event of each input stream, whenever a new event arrives on any stream.\n */\nexport const combine = <A, B, C>(f: (a: A, b: B) => C, stream1: Stream<A>, stream2: Stream<B>): Stream<C> =>\n  combineArray(f, [stream1, stream2])\n\n/**\n* Combine latest events from all input streams\n* @param f function to combine most recent events\n* @param streams most recent events\n* @returns stream containing the result of applying f to the most recent\n*  event of each input stream, whenever a new event arrives on any stream.\n*/\nexport const combineArray = <Args extends unknown[], R>(f: (...args: Args) => R, streams: ToStreamsArray<Args>): Stream<R> =>\n  streams.length === 0 || containsCanonicalEmpty(streams) ? empty()\n    : streams.length === 1 ? map(f as any, streams[0])\n      : new Combine(f, streams)\n\nclass Combine<Args extends unknown[], B> implements Stream<B> {\n  private readonly f: (...args: Args) => B\n  private readonly sources: ToStreamsArray<Args>;\n\n  constructor(f: (...args: Args) => B, sources: ToStreamsArray<Args>) {\n    this.f = f\n    this.sources = sources\n  }\n\n  run(sink: Sink<B>, scheduler: Scheduler): Disposable {\n    const l = this.sources.length\n    const disposables = new Array(l)\n    const sinks = new Array(l)\n\n    const mergeSink = new CombineSink(disposables, sinks.length, sink, this.f)\n\n    for (let indexSink, i = 0; i < l; ++i) {\n      indexSink = sinks[i] = new IndexSink(i, mergeSink)\n      disposables[i] = this.sources[i].run(indexSink, scheduler)\n    }\n\n    return disposeAll(disposables)\n  }\n}\n\nclass CombineSink<A, Args extends A[], B> extends Pipe<IndexedValue<A>, B> implements Sink<IndexedValue<A>> {\n  private readonly disposables: Disposable[]\n  private readonly f: (...args: Args) => B\n  private awaiting: number\n  private readonly hasValue: boolean[]\n  private activeCount: number\n  private readonly values: Args\n\n  constructor(disposables: Disposable[], length: number, sink: Sink<B>, f: (...args: Args) => B) {\n    super(sink)\n    this.disposables = disposables\n    this.f = f\n\n    this.awaiting = length\n    this.values = new Array(length) as Args\n    this.hasValue = new Array(length).fill(false)\n    this.activeCount = length\n  }\n\n  event(t: Time, indexedValue: IndexedValue<A>): void {\n    if (!indexedValue.active) {\n      this.dispose(t, indexedValue.index)\n      return\n    }\n\n    const i = indexedValue.index\n    const awaiting = this.updateReady(i)\n\n    this.values[i] = indexedValue.value\n    if (awaiting === 0) {\n      this.sink.event(t, invoke(this.f, this.values))\n    }\n  }\n\n  private updateReady(index: number): number {\n    if (this.awaiting > 0) {\n      if (!this.hasValue[index]) {\n        this.hasValue[index] = true\n        this.awaiting -= 1\n      }\n    }\n    return this.awaiting\n  }\n\n  private dispose(t: Time, index: number): void {\n    tryDispose(t, this.disposables[index], this.sink)\n    if (--this.activeCount === 0) {\n      this.sink.end(t)\n    }\n  }\n}\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nimport { combine } from './combine'\nimport { apply } from '@most/prelude'\nimport { Stream } from '@most/types'\n\n/**\n * Assume fs is a stream containing functions, and apply the latest function\n * in fs to the latest value in xs.\n * fs:         --f---------g--------h------>\n * xs:         -a-------b-------c-------d-->\n * ap(fs, xs): --fa-----fb-gb---gc--hc--hd->\n * @param {Stream} fs stream of functions to apply to the latest x\n * @param {Stream} xs stream of values to which to apply all the latest f\n * @returns {Stream} stream containing all the applications of fs to xs\n */\nexport function ap<A, B>(fs: Stream<(a: A) => B>, xs: Stream<A>): Stream<B> {\n  return combine(apply, fs, xs)\n}\n", "/** @license MIT License (c) copyright 2010 original author or authors */\n\nimport { disposeAll, disposeNone, disposeOnce, tryDispose } from '@most/disposable'\nimport { empty, isCanonicalEmpty } from '../source/empty'\nimport { id as identity } from '@most/prelude'\nimport { schedulerRelativeTo } from '@most/scheduler'\nimport { Time, Disposable, Sink, Scheduler, Stream } from '@most/types'\n\nexport const mergeConcurrently = <A>(concurrency: number, stream: Stream<Stream<A>>): Stream<A> =>\n  mergeMapConcurrently(identity, concurrency, stream)\n\nexport const mergeMapConcurrently = <A, B>(f: (a: A) => Stream<B>, concurrency: number, stream: Stream<A>): Stream<B> =>\n  isCanonicalEmpty(stream) ? empty()\n    : new MergeConcurrently(f, concurrency, stream)\n\nclass MergeConcurrently<A, B> implements Stream<B> {\n  private readonly concurrency: number;\n  private readonly f: (a: A) => Stream<B>\n  private readonly source: Stream<A>\n\n  constructor(f: (a: A) => Stream<B>, concurrency: number, source: Stream<A>) {\n    this.f = f\n    this.concurrency = concurrency\n    this.source = source\n  }\n\n  run(sink: Sink<B>, scheduler: Scheduler): Disposable {\n    return new Outer(this.f, this.concurrency, this.source, sink, scheduler)\n  }\n}\n\ninterface NonEmptyArray<A> extends Array<A> {\n  readonly [0]: A\n  shift(): A\n}\nconst isNonEmpty = <A>(array: A[]): array is NonEmptyArray<A> => array.length > 0\n\nclass Outer<A, B> implements Sink<A>, Disposable {\n  private readonly scheduler: Scheduler;\n  private readonly disposable: Disposable;\n  private active: boolean;\n  private readonly concurrency: number;\n  private readonly f: (a: A) => Stream<B>;\n  private readonly sink: Sink<B>;\n  private readonly current: Disposable[];\n  private readonly pending: A[];\n\n  constructor(f: (a: A) => Stream<B>, concurrency: number, source: Stream<A>, sink: Sink<B>, scheduler: Scheduler) {\n    this.f = f\n    this.concurrency = concurrency\n    this.sink = sink\n    this.scheduler = scheduler\n    this.pending = []\n    this.current = []\n    this.disposable = disposeOnce(source.run(this, scheduler))\n    this.active = true\n  }\n\n  event(t: Time, x: A): void {\n    this.addInner(t, x)\n  }\n\n  private addInner(t: Time, x: A): void {\n    if (this.current.length < this.concurrency) {\n      this.startInner(t, x)\n    } else {\n      this.pending.push(x)\n    }\n  }\n\n  private startInner(t: Time, x: A): void {\n    try {\n      this.initInner(t, x)\n    } catch (e) {\n      this.error(t, e)\n    }\n  }\n\n  private initInner(t: Time, x: A): void {\n    const innerSink = new Inner(t, this, this.sink)\n    innerSink.disposable = mapAndRun(this.f, t, x, innerSink, this.scheduler)\n    this.current.push(innerSink)\n  }\n\n  end(t: Time): void {\n    this.active = false\n    tryDispose(t, this.disposable, this.sink)\n    this.checkEnd(t)\n  }\n\n  error(t: Time, e: Error): void{\n    this.active = false\n    this.sink.error(t, e)\n  }\n\n  dispose(): void {\n    this.active = false\n    this.pending.length = 0\n    this.disposable.dispose()\n    disposeAll(this.current).dispose()\n  }\n\n  endInner(t: Time, inner: Disposable): void {\n    const i = this.current.indexOf(inner)\n    if (i >= 0) {\n      this.current.splice(i, 1)\n    }\n    tryDispose(t, inner, this)\n\n    const pending = this.pending\n    if (isNonEmpty(pending)) {\n      this.startInner(t, pending.shift())\n    } else {\n      this.checkEnd(t)\n    }\n  }\n\n  private checkEnd(t: Time): void {\n    if (!this.active && this.current.length === 0) {\n      this.sink.end(t)\n    }\n  }\n}\n\nconst mapAndRun = <A, B>(f: (a: A) => Stream<B>, t: Time, x: A, sink: Sink<B>, scheduler: Scheduler): Disposable =>\n  f(x).run(sink, schedulerRelativeTo(t, scheduler))\n\nclass Inner<A, B> implements Sink<B>, Disposable {\n  private readonly time: number;\n  private readonly outer: Outer<A, B>;\n  disposable: Disposable;\n  private readonly sink: Sink<B>;\n\n  constructor(time: Time, outer: Outer<A, B>, sink: Sink<B>) {\n    this.time = time\n    this.outer = outer\n    this.sink = sink\n    this.disposable = disposeNone()\n  }\n\n  event(t: Time, x: B): void {\n    this.sink.event(t + this.time, x)\n  }\n\n  end(t: Time): void {\n    this.outer.endInner(t + this.time, this)\n  }\n\n  error(t: Time, e: Error): void {\n    this.outer.error(t + this.time, e)\n  }\n\n  dispose(): void {\n    return this.disposable.dispose()\n  }\n}\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nimport { mergeConcurrently, mergeMapConcurrently } from './mergeConcurrently'\nimport { Stream } from '@most/types'\n\n/**\n * Map each value in the stream to a new stream, and merge it into the\n * returned outer stream. Event arrival times are preserved.\n * @param f chaining function, must return a Stream\n * @param stream\n * @returns new stream containing all events from each stream returned by f\n */\nexport const chain = <A, B>(f: (value: A) => Stream<B>, stream: Stream<A>): Stream<B> => mergeMapConcurrently(f, Infinity, stream)\n\n/**\n * Monadic join. Flatten a Stream<Stream<X>> to Stream<X> by merging inner\n * streams to the outer. Event arrival times are preserved.\n * @param stream stream of streams\n * @returns new stream containing all events of all inner streams\n */\nexport const join = <A>(stream: Stream<Stream<A>>): Stream<A> => mergeConcurrently(Infinity, stream)\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nimport { mergeMapConcurrently } from './mergeConcurrently'\nimport { Stream } from '@most/types'\n\n/**\n * Map each value in stream to a new stream, and concatenate them all\n * stream:              -a---b---cX\n * f(a):                 1-1-1-1X\n * f(b):                        -2-2-2-2X\n * f(c):                                -3-3-3-3X\n * stream.concatMap(f): -1-1-1-1-2-2-2-2-3-3-3-3X\n * @param f function to map each value to a stream\n * @param stream\n * @returns new stream containing all events from each stream returned by f\n */\nexport const concatMap = <A, B>(f: (a: A) => Stream<B>, stream: Stream<A>): Stream<B> =>\n  mergeMapConcurrently(f, 1, stream)\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nimport Pipe from '../sink/Pipe'\nimport { IndexSink, IndexedValue } from '../sink/IndexSink'\nimport { empty, isCanonicalEmpty } from '../source/empty'\nimport { disposeAll, tryDispose } from '@most/disposable'\nimport { reduce } from '@most/prelude'\nimport { Stream, Time, Disposable, Sink, Scheduler } from '@most/types'\n\n/**\n * @returns stream containing events from two streams in time order.\n * If two events are simultaneous they will be merged in arbitrary order.\n */\nexport function merge <A, B>(stream1: Stream<A>, stream2: Stream<B>): Stream<A | B> {\n  return mergeArray([stream1, stream2])\n}\n\n// TODO: use readonly Stream<any>[] once TS 3.4.x has been in the wild for \"enough\" time\ntype MergeArray<S extends ReadonlyArray<Stream<any>>> = Value<S[number]>\ntype Value<S> = S extends Stream<infer A> ? A : never\n\n/**\n * @param streams array of stream to merge\n * @returns stream containing events from all input observables\n * in time order.  If two events are simultaneous they will be merged in\n * arbitrary order.\n */\nexport const mergeArray = <S extends ReadonlyArray<Stream<any>>>(streams: S): Stream<MergeArray<S>> =>\n  mergeStreams(withoutCanonicalEmpty(streams))\n\n/**\n * This implements fusion/flattening for merge.  It will\n * fuse adjacent merge operations.  For example:\n * - a.merge(b).merge(c) effectively becomes merge(a, b, c)\n * - merge(a, merge(b, c)) effectively becomes merge(a, b, c)\n * It does this by concatenating the sources arrays of\n * any nested Merge sources, in effect \"flattening\" nested\n * merge operations into a single merge.\n * TODO: use {@link MergeArray}\n */\nconst mergeStreams = <A>(streams: Stream<A>[]): Stream<A> =>\n  streams.length === 0 ? empty()\n    : streams.length === 1 ? streams[0]\n      : new Merge(reduce<Stream<A>[], Stream<A>>(appendSources, [], streams))\n\nconst withoutCanonicalEmpty = <A>(streams: ReadonlyArray<Stream<A>>): Stream<A>[] =>\n  streams.filter(isNotCanonicalEmpty)\n\nconst isNotCanonicalEmpty = <A>(stream: Stream<A>): boolean =>\n  !isCanonicalEmpty(stream)\n\nconst appendSources = <A>(sources: Stream<A>[], stream: Stream<A>): Stream<A>[] =>\n  sources.concat(stream instanceof Merge ? stream.sources : stream)\n\nclass Merge<A> implements Stream<A> {\n  readonly sources: Stream<A>[];\n\n  constructor(sources: Stream<A>[]) {\n    this.sources = sources\n  }\n\n  run(sink: Sink<A>, scheduler: Scheduler): Disposable {\n    const l = this.sources.length\n    const disposables: Disposable[] = new Array(l)\n    const sinks: Sink<A>[] = new Array(l)\n\n    const mergeSink = new MergeSink(disposables, sinks, sink)\n\n    for (let indexSink, i = 0; i < l; ++i) {\n      indexSink = sinks[i] = new IndexSink(i, mergeSink)\n      disposables[i] = this.sources[i].run(indexSink, scheduler)\n    }\n\n    return disposeAll(disposables)\n  }\n}\n\nclass MergeSink<A> extends Pipe<IndexedValue<A>, A> implements Sink<IndexedValue<A>> {\n  private readonly disposables: Disposable[];\n  private activeCount: number;\n\n  constructor(disposables: Disposable[], sinks: Sink<unknown>[], sink: Sink<A>) {\n    super(sink)\n    this.disposables = disposables\n    this.activeCount = sinks.length\n  }\n\n  event(t: Time, indexValue: IndexedValue<A>): void {\n    if (!indexValue.active) {\n      this.dispose(t, indexValue.index)\n      return\n    }\n    this.sink.event(t, indexValue.value)\n  }\n\n  private dispose(t: Time, index: number): void {\n    tryDispose(t, this.disposables[index], this.sink)\n    if (--this.activeCount === 0) {\n      this.sink.end(t)\n    }\n  }\n}\n", "/** @license MIT License (c) copyright 2010 original author or authors */\n\nimport Pipe from '../sink/Pipe'\nimport { disposeBoth } from '@most/disposable'\nimport { empty, isCanonicalEmpty } from '../source/empty'\nimport { Stream, Sink, Scheduler, Time, Disposable } from '@most/types'\n\nexport const sample = <A, B>(values: Stream<A>, sampler: Stream<B>): Stream<A> =>\n  snapshot(x => x, values, sampler)\n\nexport const snapshot = <A, B, C>(f: (a: A, b: B) => C, values: Stream<A>, sampler: Stream<B>): Stream<C> =>\n  isCanonicalEmpty(sampler) || isCanonicalEmpty(values)\n    ? empty()\n    : new Snapshot(f, values, sampler)\n\nexport class Snapshot<A, B, C> implements Stream<C> {\n  private readonly f: (a: A, b: B) => C\n  private readonly values: Stream<A>\n  private readonly sampler: Stream<B>\n\n  constructor(f: (a: A, b: B) => C, values: Stream<A>, sampler: Stream<B>) {\n    this.f = f\n    this.values = values\n    this.sampler = sampler\n  }\n\n  run(sink: Sink<C>, scheduler: Scheduler): Disposable {\n    const sampleSink = new SnapshotSink(this.f, sink)\n    const valuesDisposable = this.values.run(sampleSink.latest, scheduler)\n    const samplerDisposable = this.sampler.run(sampleSink, scheduler)\n\n    return disposeBoth(samplerDisposable, valuesDisposable)\n  }\n}\n\nexport class SnapshotSink<A, B, C> extends Pipe<B, C> implements Sink<B> {\n  private readonly f: (a: A, b: B) => C\n  readonly latest: LatestValueSink<A>;\n\n  constructor(f: (a: A, b: B) => C, sink: Sink<C>) {\n    super(sink)\n    this.f = f\n    this.latest = new LatestValueSink(this)\n  }\n\n  event(t: Time, x: B): void {\n    if (this.latest.hasValue) {\n      const f = this.f\n      // TODO: value should be boxed to avoid ! bang\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      this.sink.event(t, f(this.latest.value!, x))\n    }\n  }\n}\n\nexport class LatestValueSink<A> extends Pipe<A, A> implements Sink<A> {\n  hasValue: boolean;\n  value?: A;\n\n  constructor(sink: Sink<unknown>) {\n    super(sink)\n    this.hasValue = false\n  }\n\n  event(_t: Time, x: A): void {\n    this.value = x\n    this.hasValue = true\n  }\n\n  end(): void {}\n}\n", "/** @license MIT License (c) copyright 2010 original author or authors */\n\n// A slice Bounds type that narrows min values via accumulation\n// and max values via Math.min.\n// type Bounds = { min: number, max: number }\n// Notes:\n// 0 <= min <= max\n// slice(min2, max2, slice(min1, max1, s)) ~ slice(min1 + min2, Math.min(max1, min1 + max2), s)\n// A bounds has a 1d coord system with origin 0, extending to Infinity.  Both min and max\n// are relative to the origin (0).  However, when merging bounds b1 and b2, we\n// *interpret* b2 as being relative to b1, hence adding min1 to *both* min2 and max2.\n// This essentially translates b2's coordinates back into origin coordinates\n// as bounds are merged.\n\nexport interface Bounds {\n  readonly min: number\n  readonly max: number\n}\n\n// Construct a constrained bounds\nexport const boundsFrom = (unsafeMin: number, unsafeMax: number): Bounds => {\n  const min = Math.max(0, unsafeMin)\n  const max = Math.max(min, unsafeMax)\n  return { min, max }\n}\n\n// Combine 2 bounds by narrowing min and max\nexport const mergeBounds = (b1: Bounds, b2: Bounds): Bounds =>\n  boundsFrom(b1.min + b2.min, Math.min(b1.max, b1.min + b2.max))\n\n// Nil bounds excludes all slice indices\nexport const isNilBounds = (b: Bounds): boolean =>\n  b.min >= b.max\n\n// Infinite bounds includes all slice indices\nexport const isInfiniteBounds = (b: Bounds): boolean =>\n  b.min <= 0 && b.max === Infinity\n", "import { empty, isCanonicalEmpty } from '../../source/empty'\nimport { boundsFrom, isNilBounds, isInfiniteBounds, mergeBounds, Bounds } from './bounds'\nimport Map from '../../fusion/Map'\nimport Pipe from '../../sink/Pipe'\nimport SettableDisposable from '../../disposable/SettableDisposable'\nimport { Stream, Sink, Scheduler, Disposable, Time } from '@most/types'\n\n// TODO: split into smaller files\n\n/**\n * @param n\n * @param stream\n * @returns new stream containing only up to the first n items from stream\n */\nexport const take = <A>(n: number, stream: Stream<A>): Stream<A> =>\n  slice(0, n, stream)\n\n/**\n * @param n\n * @param stream\n * @returns new stream with the first n items removed\n */\nexport const skip = <A>(n: number, stream: Stream<A>): Stream<A> =>\n  slice(n, Infinity, stream)\n\n/**\n * Slice a stream by index. Negative start/end indexes are not supported\n * @param start\n * @param end\n * @param stream\n * @returns stream containing items where start <= index < end\n */\nexport const slice = <A>(start: number, end: number, stream: Stream<A>): Stream<A> =>\n  sliceBounds(boundsFrom(start, end), stream)\n\nconst sliceBounds = <A>(bounds: Bounds, stream: Stream<A>): Stream<A> =>\n  isSliceEmpty(bounds, stream) ? empty()\n    : stream instanceof Map ? commuteMapSlice(bounds, stream)\n      : stream instanceof Slice ? fuseSlice(bounds, stream)\n        : createSlice(bounds, stream)\n\nconst isSliceEmpty = <A>(bounds: Bounds, stream: Stream<A>): boolean =>\n  isCanonicalEmpty(stream) || isNilBounds(bounds)\n\nconst createSlice = <A>(bounds: Bounds, stream: Stream<A>): Stream<A> =>\n  isInfiniteBounds(bounds) ? stream : new Slice(bounds, stream)\n\nconst commuteMapSlice = <A, B>(bounds: Bounds, mapStream: Map<A, B>): Stream<B> =>\n  Map.create(mapStream.f, sliceBounds(bounds, mapStream.source))\n\nconst fuseSlice = <A>(bounds: Bounds, sliceStream: Slice<A>): Stream<A> =>\n  sliceBounds(mergeBounds(sliceStream.bounds, bounds), sliceStream.source)\n\nexport class Slice<A> implements Stream<A> {\n  readonly bounds: Bounds;\n  readonly source: Stream<A>;\n\n  constructor(bounds: Bounds, source: Stream<A>) {\n    this.source = source\n    this.bounds = bounds\n  }\n\n  run(sink: Sink<A>, scheduler: Scheduler): Disposable {\n    const disposable = new SettableDisposable()\n    const sliceSink = new SliceSink(this.bounds.min, this.bounds.max - this.bounds.min, sink, disposable)\n\n    disposable.setDisposable(this.source.run(sliceSink, scheduler))\n\n    return disposable\n  }\n}\n\nclass SliceSink<A> extends Pipe<A, A> implements Sink<A> {\n  private skip: number\n  private take: number\n  private readonly disposable: Disposable\n  constructor(skip: number, take: number, sink: Sink<A>, disposable: Disposable) {\n    super(sink)\n    this.skip = skip\n    this.take = take\n    this.disposable = disposable\n  }\n\n  event(t: Time, x: A): void {\n    /* eslint complexity: [1, 4] */\n    if (this.skip > 0) {\n      this.skip -= 1\n      return\n    }\n\n    if (this.take === 0) {\n      return\n    }\n\n    this.take -= 1\n    this.sink.event(t, x)\n    if (this.take === 0) {\n      this.disposable.dispose()\n      this.sink.end(t)\n    }\n  }\n}\n\nexport const takeWhile = <A>(p: (a: A) => boolean, stream: Stream<A>): Stream<A> =>\n  isCanonicalEmpty(stream) ? empty()\n    : new TakeWhile(p, stream)\n\nclass TakeWhile<A> implements Stream<A> {\n  private readonly p: (a: A) => boolean;\n  private readonly source: Stream<A>;\n\n  constructor(p: (a: A) => boolean, source: Stream<A>) {\n    this.p = p\n    this.source = source\n  }\n\n  run(sink: Sink<A>, scheduler: Scheduler): Disposable {\n    const disposable = new SettableDisposable()\n    const takeWhileSink = new TakeWhileSink(this.p, sink, disposable)\n\n    disposable.setDisposable(this.source.run(takeWhileSink, scheduler))\n\n    return disposable\n  }\n}\n\nclass TakeWhileSink<A> extends Pipe<A, A> implements Sink<A> {\n  private readonly p: (a: A) => boolean\n  private readonly disposable: Disposable\n  private active: boolean;\n\n  constructor(p: (a: A) => boolean, sink: Sink<A>, disposable: Disposable) {\n    super(sink)\n    this.p = p\n    this.active = true\n    this.disposable = disposable\n  }\n\n  event(t: Time, x: A): void {\n    if (!this.active) {\n      return\n    }\n\n    const p = this.p\n    this.active = p(x)\n\n    if (this.active) {\n      this.sink.event(t, x)\n    } else {\n      this.disposable.dispose()\n      this.sink.end(t)\n    }\n  }\n}\n\nexport const skipWhile = <A>(p: (a: A) => boolean, stream: Stream<A>): Stream<A> =>\n  isCanonicalEmpty(stream) ? empty()\n    : new SkipWhile(p, stream)\n\nclass SkipWhile<A> implements Stream<A> {\n  private readonly p: (a: A) => boolean\n  private readonly source: Stream<A>\n\n  constructor(p: (a: A) => boolean, source: Stream<A>) {\n    this.p = p\n    this.source = source\n  }\n\n  run(sink: Sink<A>, scheduler: Scheduler): Disposable {\n    return this.source.run(new SkipWhileSink(this.p, sink), scheduler)\n  }\n}\n\nclass SkipWhileSink<A> extends Pipe<A, A> implements Sink<A> {\n  private readonly p: (a: A) => boolean;\n  private skipping: boolean;\n\n  constructor(p: (a: A) => boolean, sink: Sink<A>) {\n    super(sink)\n    this.p = p\n    this.skipping = true\n  }\n\n  event(t: Time, x: A): void {\n    if (this.skipping) {\n      const p = this.p\n      this.skipping = p(x)\n      if (this.skipping) {\n        return\n      }\n    }\n\n    this.sink.event(t, x)\n  }\n}\n\nexport const skipAfter = <A>(p: (a: A) => boolean, stream: Stream<A>): Stream<A> =>\n  isCanonicalEmpty(stream) ? empty()\n    : new SkipAfter(p, stream)\n\nclass SkipAfter<A> implements Stream<A> {\n  private readonly p: (a: A) => boolean\n  private readonly source: Stream<A>\n\n  constructor(p: (a: A) => boolean, source: Stream<A>) {\n    this.p = p\n    this.source = source\n  }\n\n  run(sink: Sink<A>, scheduler: Scheduler): Disposable {\n    return this.source.run(new SkipAfterSink(this.p, sink), scheduler)\n  }\n}\n\nclass SkipAfterSink<A> extends Pipe<A, A> implements Sink<A> {\n  private readonly p: (a: A) => boolean;\n  private skipping: boolean;\n\n  constructor(p: (a: A) => boolean, sink: Sink<A>) {\n    super(sink)\n    this.p = p\n    this.skipping = false\n  }\n\n  event(t: Time, x: A): void {\n    if (this.skipping) {\n      return\n    }\n\n    const p = this.p\n    this.skipping = p(x)\n    this.sink.event(t, x)\n\n    if (this.skipping) {\n      this.sink.end(t)\n    }\n  }\n}\n", "/** @license MIT License (c) copyright 2017 original author or authors */\n\nimport Pipe from '../sink/Pipe'\nimport { empty, isCanonicalEmpty } from '../source/empty'\nimport { take } from './slice'\nimport { Stream, Sink, Scheduler, Disposable, Time } from '@most/types'\n\nexport const withItems = <A> (items: Array<A>, stream: Stream<unknown>): Stream<A> =>\n  zipItems(keepLeft, items, stream)\n\nexport const zipItems = <A, B, C> (f: (a: A, b: B) => C, items: ArrayLike<A>, stream: Stream<B>): Stream<C> =>\n  isCanonicalEmpty(stream) || items.length === 0\n    ? empty()\n    : new ZipItems(f, items, take(items.length, stream))\n\nconst keepLeft = <A>(a: A): A => a\n\nclass ZipItems<A, B, C> implements Stream<C> {\n  private readonly f: (a: A, b: B) => C\n  private readonly items: ArrayLike<A>\n  private readonly source: Stream<B>\n\n  constructor(f: (a: A, b: B) => C, items: ArrayLike<A>, source: Stream<B>) {\n    this.f = f\n    this.items = items\n    this.source = source\n  }\n\n  run(sink: Sink<C>, scheduler: Scheduler): Disposable {\n    return this.source.run(new ZipItemsSink(this.f, this.items, sink), scheduler)\n  }\n}\n\nclass ZipItemsSink<A, B, C> extends Pipe<B, C> implements Sink<B> {\n  private readonly f: (a: A, b: B) => C\n  private readonly items: ArrayLike<A>\n  private index: number;\n\n  constructor(f: (a: A, b: B) => C, items: ArrayLike<A>, sink: Sink<C>) {\n    super(sink)\n    this.f = f\n    this.items = items\n    this.index = 0\n  }\n\n  event(t: Time, b: B): void {\n    const f = this.f\n    this.sink.event(t, f(this.items[this.index], b))\n    this.index += 1\n  }\n}\n", "// Copied and modified from https://github.com/invertase/denque\n// MIT License\n\n// These constants were extracted directly from denque's shift()\n// It's not clear exactly why the authors chose these particular\n// values, but given denque's stated goals, it seems likely that\n// they were chosen for speed/memory reasons.\n\n// Max value of _head at which Queue is willing to shink\n// its internal array\nconst HEAD_MAX_SHRINK = 2\n\n// Min value of _tail at which Queue is willing to shink\n// its internal array\nconst TAIL_MIN_SHRINK = 10000\n\nexport default class Queue<A> {\n  private head: number;\n  private tail: number;\n  private capacityMask: number;\n  private list: Array<A | undefined>;\n\n  constructor() {\n    this.head = 0\n    this.tail = 0\n    this.capacityMask = 0x3\n    this.list = new Array(4)\n  }\n\n  push(x: A): number {\n    const tail = this.tail\n    this.list[tail] = x\n    this.tail = (tail + 1) & this.capacityMask\n    if (this.tail === this.head) {\n      this.growArray()\n    }\n\n    if (this.head < this.tail) {\n      return this.tail - this.head\n    } else {\n      return this.capacityMask + 1 - (this.head - this.tail)\n    }\n  }\n\n  shift(): A | undefined {\n    const head = this.head\n    if (head === this.tail) {\n      return undefined\n    }\n\n    const x = this.list[head]\n    this.list[head] = undefined\n    this.head = (head + 1) & this.capacityMask\n    if (head < HEAD_MAX_SHRINK &&\n      this.tail > TAIL_MIN_SHRINK &&\n      this.tail <= this.list.length >>> 2) {\n      this.shrinkArray()\n    }\n\n    return x\n  }\n\n  isEmpty(): boolean {\n    return this.head === this.tail\n  }\n\n  length(): number {\n    if (this.head === this.tail) {\n      return 0\n    } else if (this.head < this.tail) {\n      return this.tail - this.head\n    } else {\n      return this.capacityMask + 1 - (this.head - this.tail)\n    }\n  }\n\n  private growArray(): void {\n    if (this.head) {\n      // copy existing data, head to end, then beginning to tail.\n      this.list = this.copyArray()\n      this.head = 0\n    }\n\n    // head is at 0 and array is now full, safe to extend\n    this.tail = this.list.length\n\n    this.list.length *= 2\n    this.capacityMask = (this.capacityMask << 1) | 1\n  }\n\n  private shrinkArray(): void {\n    this.list.length >>>= 1\n    this.capacityMask >>>= 1\n  }\n\n  private copyArray(): Array<A | undefined> {\n    const newArray: Array<A | undefined> = []\n    const list = this.list\n    const len = list.length\n\n    let i\n    for (i = this.head; i < len; i++) {\n      newArray.push(list[i])\n    }\n    for (i = 0; i < this.tail; i++) {\n      newArray.push(list[i])\n    }\n\n    return newArray\n  }\n}\n", "/** @license MIT License (c) copyright 2010 original author or authors */\n\nimport { map } from './transform'\nimport { empty, containsCanonicalEmpty } from '../source/empty'\nimport Pipe from '../sink/Pipe'\nimport { IndexSink, IndexedValue } from '../sink/IndexSink'\nimport { disposeAll } from '@most/disposable'\nimport { map as mapArray } from '@most/prelude'\nimport invoke from '../invoke'\nimport Queue from '../Queue'\nimport { Stream, Sink, Scheduler, Disposable, Time } from '@most/types'\nimport { ToStreamsArray } from './variadic'\n\ninterface NonEmptyQueue<A> extends Queue<A> {\n  shift(): A\n}\n\n/**\n * Combine two streams pairwise by index by applying f to values at corresponding\n * indices.  The returned stream ends when either of the input streams ends.\n * @param {function} f function to combine values\n * @returns {Stream} new stream with items at corresponding indices combined\n *  using f\n */\nexport function zip <A, B, R>(f: (a: A, b: B) => R, stream1: Stream<A>, stream2: Stream<B>): Stream<R> {\n  return zipArray(f, [stream1, stream2])\n}\n\n/**\n* Combine streams pairwise (or tuple-wise) by index by applying f to values\n* at corresponding indices.  The returned stream ends when any of the input\n* streams ends.\n* @param {function} f function to combine values\n* @param {[Stream]} streams streams to zip using f\n* @returns {Stream} new stream with items at corresponding indices combined\n*  using f\n*/\nexport const zipArray = <Args extends unknown[], R>(f: (...args: Args) => R, streams: ToStreamsArray<Args>): Stream<R> =>\n  streams.length === 0 || containsCanonicalEmpty(streams) ? empty()\n    : streams.length === 1 ? map(f as any, streams[0])\n      : new Zip(f as any, streams)\n\nclass Zip<A, R> implements Stream<R> {\n  private readonly f: (...args: ReadonlyArray<A>) => R\n  private readonly sources: ArrayLike<Stream<A>>\n\n  constructor(f: (...args: ReadonlyArray<A>) => R, sources: ArrayLike<Stream<A>>) {\n    this.f = f\n    this.sources = sources\n  }\n\n  run(sink: Sink<R>, scheduler: Scheduler): Disposable {\n    const l = this.sources.length\n    const disposables = new Array(l)\n    const sinks = new Array(l)\n    const buffers = new Array(l)\n\n    const zipSink = new ZipSink(this.f, buffers, sinks, sink)\n\n    for (let indexSink, i = 0; i < l; ++i) {\n      buffers[i] = new Queue()\n      indexSink = sinks[i] = new IndexSink(i, zipSink)\n      disposables[i] = this.sources[i].run(indexSink, scheduler)\n    }\n\n    return disposeAll(disposables)\n  }\n}\n\nclass ZipSink<A, R> extends Pipe<IndexedValue<A>, R> implements Sink<IndexedValue<A>> {\n  private readonly f: (...args: ReadonlyArray<A>) => R\n  private readonly buffers: ArrayLike<Queue<A>>\n  private readonly sinks: ArrayLike<IndexSink<A>>\n\n  constructor(f: (...args: ReadonlyArray<A>) => R, buffers: ArrayLike<Queue<A>>, sinks: ArrayLike<IndexSink<A>>, sink: Sink<R>) {\n    super(sink)\n    this.f = f\n    this.sinks = sinks\n    this.buffers = buffers\n  }\n\n  event(t: Time, indexedValue: IndexedValue<A>): void {\n    /* eslint complexity: [1, 5] */\n    if (!indexedValue.active) {\n      this.dispose(t, indexedValue.index)\n      return\n    }\n\n    const buffers = this.buffers\n    const buffer = buffers[indexedValue.index]\n\n    buffer.push(indexedValue.value)\n\n    if (buffer.length() === 1) {\n      if (!ready(buffers)) {\n        return\n      }\n\n      emitZipped(this.f, t, buffers, this.sink)\n\n      if (ended(this.buffers, this.sinks)) {\n        this.sink.end(t)\n      }\n    }\n  }\n\n  private dispose(t: Time, index: number): void {\n    const buffer = this.buffers[index]\n    if (buffer.isEmpty()) {\n      this.sink.end(t)\n    }\n  }\n}\n\nconst emitZipped = <A, R>(f: (...args: A[]) => R, t: Time, buffers: ArrayLike<NonEmptyQueue<A>>, sink: Sink<R>): void =>\n  sink.event(t, invoke(f, mapArray(head, buffers)))\n\nconst head = <A>(buffer: NonEmptyQueue<A>): A => buffer.shift()\n\nfunction ended <A>(buffers: ArrayLike<Queue<unknown>>, sinks: ArrayLike<IndexSink<A>>): boolean {\n  for (let i = 0, l = buffers.length; i < l; ++i) {\n    if (buffers[i].isEmpty() && !sinks[i].active) {\n      return true\n    }\n  }\n  return false\n}\n\nfunction ready <A>(buffers: ArrayLike<Queue<A>>): buffers is ArrayLike<NonEmptyQueue<A>> {\n  for (let i = 0, l = buffers.length; i < l; ++i) {\n    if (buffers[i].isEmpty()) {\n      return false\n    }\n  }\n  return true\n}\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nimport { disposeBoth, tryDispose } from '@most/disposable'\nimport { schedulerRelativeTo, currentTime } from '@most/scheduler'\nimport { empty, isCanonicalEmpty } from '../source/empty'\nimport { Stream, Sink, Scheduler, Disposable, Time } from '@most/types'\n\n/**\n * Given a stream of streams, return a new stream that adopts the behavior\n * of the most recent inner stream.\n * @param stream of streams on which to switch\n * @returns switching stream\n */\nexport const switchLatest = <A>(stream: Stream<Stream<A>>): Stream<A> =>\n  isCanonicalEmpty(stream)\n    ? empty()\n    : new Switch(stream)\n\nclass Switch<A> implements Stream<A> {\n  private readonly source: Stream<Stream<A>>\n\n  constructor(source: Stream<Stream<A>>) {\n    this.source = source\n  }\n\n  run(sink: Sink<A>, scheduler: Scheduler): Disposable {\n    const switchSink = new SwitchSink(sink, scheduler)\n    return disposeBoth(switchSink, this.source.run(switchSink, scheduler))\n  }\n}\n\nclass SwitchSink<A> implements Sink<Stream<A>>, Disposable {\n  private readonly sink: Sink<A>\n  private readonly scheduler: Scheduler\n  private ended: boolean\n  private current: Segment<A> | null\n\n  constructor(sink: Sink<A>, scheduler: Scheduler) {\n    this.sink = sink\n    this.scheduler = scheduler\n    this.current = null\n    this.ended = false\n  }\n\n  event(t: Time, stream: Stream<A>): void {\n    this.disposeCurrent(t)\n    this.current = new Segment(stream, t, Infinity, this, this.sink, this.scheduler)\n  }\n\n  end(t: Time): void {\n    this.ended = true\n    this.checkEnd(t)\n  }\n\n  error(t: Time, e: Error): void {\n    this.ended = true\n    this.sink.error(t, e)\n  }\n\n  dispose(): void {\n    return this.disposeCurrent(currentTime(this.scheduler))\n  }\n\n  private disposeCurrent(t: Time): void {\n    if (this.current !== null) {\n      return this.current.dispose(t)\n    }\n  }\n\n  private disposeInner(t: Time, inner: Segment<A>): void {\n    inner.dispose(t)\n    if (inner === this.current) {\n      this.current = null\n    }\n  }\n\n  private checkEnd(t: Time): void {\n    if (this.ended && this.current === null) {\n      this.sink.end(t)\n    }\n  }\n\n  endInner(t: Time, inner: Segment<A>): void {\n    this.disposeInner(t, inner)\n    this.checkEnd(t)\n  }\n\n  errorInner(t: Time, e: Error, inner: Segment<A>): void {\n    this.disposeInner(t, inner)\n    this.sink.error(t, e)\n  }\n}\n\nclass Segment<A> implements Sink<A> {\n  private readonly min: Time\n  private readonly max: Time\n  private readonly outer: SwitchSink<A>\n  private readonly sink: Sink<A>\n  private readonly disposable: Disposable\n\n  constructor(source: Stream<A>, min: Time, max: Time, outer: SwitchSink<A>, sink: Sink<A>, scheduler: Scheduler) {\n    this.min = min\n    this.max = max\n    this.outer = outer\n    this.sink = sink\n    this.disposable = source.run(this, schedulerRelativeTo(min, scheduler))\n  }\n\n  event(t: Time, x: A): void {\n    const time = Math.max(0, t + this.min)\n    if (time < this.max) {\n      this.sink.event(time, x)\n    }\n  }\n\n  end(t: Time): void {\n    this.outer.endInner(t + this.min, this)\n  }\n\n  error(t: Time, e: Error): void {\n    this.outer.errorInner(t + this.min, e, this)\n  }\n\n  dispose(t: Time): void {\n    tryDispose(t, this.disposable, this.sink)\n  }\n}\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nimport Pipe from '../sink/Pipe'\nimport Filter from '../fusion/Filter'\nimport { empty, isCanonicalEmpty } from '../source/empty'\nimport { Stream, Sink, Scheduler, Time, Disposable } from '@most/types'\n\n/**\n * Retain only items matching a predicate\n * @param p filtering predicate called for each item\n * @param stream stream to filter\n * @returns stream containing only items for which predicate returns truthy\n */\nexport function filter<A, B extends A>(p: (a: A) => a is B, stream: Stream<A>): Stream<B>\nexport function filter<A>(p: (a: A) => boolean, stream: Stream<A>): Stream<A>\nexport function filter<A>(p: (a: A) => boolean, stream: Stream<A>): Stream<A> {\n  return Filter.create(p, stream)\n}\n\n/**\n * Skip repeated events, using === to detect duplicates\n * @param stream stream from which to omit repeated events\n * @returns stream without repeated events\n */\nexport const skipRepeats = <A>(stream: Stream<A>): Stream<A> =>\n  skipRepeatsWith(same, stream)\n\n/**\n * Skip repeated events using the provided equals function to detect duplicates\n * @param equals optional function to compare items\n * @param stream stream from which to omit repeated events\n * @returns stream without repeated events\n */\nexport const skipRepeatsWith = <A>(equals: (a1: A, a2: A) => boolean, stream: Stream<A>): Stream<A> =>\n  isCanonicalEmpty(stream) ? empty()\n    : new SkipRepeats(equals, stream)\n\nclass SkipRepeats<A> implements Stream<A> {\n  private readonly equals: (a1: A, a2: A) => boolean\n  private readonly source: Stream<A>\n  constructor(equals: (a1: A, a2: A) => boolean, source: Stream<A>) {\n    this.equals = equals\n    this.source = source\n  }\n\n  run(sink: Sink<A>, scheduler: Scheduler): Disposable {\n    return this.source.run(new SkipRepeatsSink(this.equals, sink), scheduler)\n  }\n}\n\nclass SkipRepeatsSink<A> extends Pipe<A, A> implements Sink<A> {\n  private readonly equals: (a1: A, a2: A) => boolean\n  private value?: A;\n  private init: boolean;\n  constructor(equals: (a1: A, a2: A) => boolean, sink: Sink<A>) {\n    super(sink)\n    this.equals = equals\n    this.value = undefined\n    this.init = true\n  }\n\n  event(t: Time, x: A): void {\n    if (this.init) {\n      this.init = false\n      this.value = x\n      this.sink.event(t, x)\n      // TODO: value should be boxed to avoid ! bang\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    } else if (!this.equals(this.value!, x)) {\n      this.value = x\n      this.sink.event(t, x)\n    }\n  }\n}\n\nfunction same <A>(a: A, b: A): boolean {\n  return a === b\n}\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nimport Pipe from '../sink/Pipe'\nimport { disposeBoth } from '@most/disposable'\nimport { join } from './chain'\nimport SettableDisposable from '../disposable/SettableDisposable'\nimport { Stream, Scheduler, Sink, Disposable, Time } from '@most/types'\n\nexport const until = <A>(signal: Stream<unknown>, stream: Stream<A>): Stream<A> =>\n  new Until(signal, stream)\n\nexport const since = <A>(signal: Stream<unknown>, stream: Stream<A>): Stream<A> =>\n  new Since(signal, stream)\n\nexport const during = <A>(timeWindow: Stream<Stream<unknown>>, stream: Stream<A>): Stream<A> =>\n  until(join(timeWindow), since(timeWindow, stream))\n\nclass Until<A> implements Stream<A> {\n  private readonly maxSignal: Stream<unknown>\n  private readonly source: Stream<A>\n\n  constructor(maxSignal: Stream<unknown>, source: Stream<A>) {\n    this.maxSignal = maxSignal\n    this.source = source\n  }\n\n  run(sink: Sink<A>, scheduler: Scheduler): Disposable {\n    const disposable = new SettableDisposable()\n\n    const d1 = this.source.run(sink, scheduler)\n    const d2 = this.maxSignal.run(new UntilSink(sink, disposable), scheduler)\n    disposable.setDisposable(disposeBoth(d1, d2))\n\n    return disposable\n  }\n}\n\nclass Since<A> implements Stream<A> {\n  private readonly minSignal: Stream<Stream<unknown>>\n  private readonly source: Stream<A>\n\n  constructor(minSignal: Stream<Stream<unknown>>, source: Stream<A>) {\n    this.minSignal = minSignal\n    this.source = source\n  }\n\n  run(sink: Sink<A>, scheduler: Scheduler): Disposable {\n    const min = new LowerBoundSink(this.minSignal, sink, scheduler)\n    const d = this.source.run(new SinceSink(min, sink), scheduler)\n\n    return disposeBoth(min, d)\n  }\n}\n\nclass SinceSink<A> extends Pipe<A, A> implements Sink<A> {\n  private readonly min: LowerBoundSink<A>\n\n  constructor(min: LowerBoundSink<A>, sink: Sink<A>) {\n    super(sink)\n    this.min = min\n  }\n\n  event(t: Time, x: A): void {\n    if (this.min.allow) {\n      this.sink.event(t, x)\n    }\n  }\n}\n\nclass LowerBoundSink<A> extends Pipe<A, A> implements Sink<A>, Disposable {\n  allow: boolean\n  private disposable: Disposable\n\n  constructor(signal: Stream<unknown>, sink: Sink<A>, scheduler: Scheduler) {\n    super(sink)\n    this.allow = false\n    this.disposable = signal.run(this, scheduler)\n  }\n\n  event(): void {\n    this.allow = true\n    this.dispose()\n  }\n\n  end(): void {}\n\n  dispose(): void {\n    this.disposable.dispose()\n  }\n}\n\nclass UntilSink<A> extends Pipe<A, A> implements Sink<A> {\n  private readonly disposable: Disposable\n\n  constructor(sink: Sink<A>, disposable: Disposable) {\n    super(sink)\n    this.disposable = disposable\n  }\n\n  event(t: Time): void {\n    this.disposable.dispose()\n    this.sink.end(t)\n  }\n\n  end(): void {}\n}\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nimport Pipe from '../sink/Pipe'\nimport { disposeBoth } from '@most/disposable'\nimport { cancelTask, delay as scheduleDelay } from '@most/scheduler'\nimport { propagateEndTask, propagateEventTask } from '../scheduler/PropagateTask'\nimport { Stream, Sink, Scheduler, Disposable, ScheduledTask, Time } from '@most/types'\n\n/**\n * @param delayTime milliseconds to delay each item\n * @param stream\n * @returns new stream containing the same items, but delayed by ms\n */\nexport const delay = <A>(delayTime: number, stream: Stream<A>): Stream<A> =>\n  delayTime <= 0 ? stream : new Delay(delayTime, stream)\n\nclass Delay<A> implements Stream<A> {\n  private readonly dt: number\n  private readonly source: Stream<A>\n\n  constructor(dt: number, source: Stream<A>) {\n    this.dt = dt\n    this.source = source\n  }\n\n  run(sink: Sink<A>, scheduler: Scheduler): Disposable {\n    const delaySink = new DelaySink(this.dt, sink, scheduler)\n    return disposeBoth(delaySink, this.source.run(delaySink, scheduler))\n  }\n}\n\nclass DelaySink<A> extends Pipe<A, A> implements Sink<A>, Disposable {\n  private readonly dt: number;\n  private readonly scheduler: Scheduler;\n  private readonly tasks: ScheduledTask[];\n  constructor(dt: number, sink: Sink<A>, scheduler: Scheduler) {\n    super(sink)\n    this.dt = dt\n    this.scheduler = scheduler\n    this.tasks = []\n  }\n\n  dispose(): void {\n    this.tasks.forEach(cancelTask)\n  }\n\n  event(_t: Time, x: A): void {\n    this.tasks.push(scheduleDelay(this.dt, propagateEventTask(x, this.sink), this.scheduler))\n  }\n\n  end(): void {\n    this.tasks.push(scheduleDelay(this.dt, propagateEndTask(this.sink), this.scheduler))\n  }\n}\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nimport Pipe from '../sink/Pipe'\nimport Map from '../fusion/Map'\nimport { empty, isCanonicalEmpty } from '../source/empty'\nimport { delay } from '@most/scheduler'\nimport { Stream, Time, Sink, Scheduler, Disposable, ScheduledTask, Task } from '@most/types'\n\n/**\n * Limit the rate of events by suppressing events that occur too often\n * @param period time to suppress events\n * @param stream\n */\nexport const throttle = <A>(period: number, stream: Stream<A>): Stream<A> =>\n  isCanonicalEmpty(stream) ? empty()\n    : stream instanceof Map ? commuteMapThrottle(period, stream)\n      : stream instanceof Throttle ? fuseThrottle(period, stream)\n        : new Throttle(period, stream)\n\nconst commuteMapThrottle = <A, B>(period: number, mapStream: Map<A, B>): Stream<B> =>\n  Map.create(mapStream.f, throttle(period, mapStream.source))\n\nconst fuseThrottle = <A>(period: number, throttleStream: Throttle<A>): Stream<A> =>\n  new Throttle(Math.max(period, throttleStream.period), throttleStream.source)\n\nexport class Throttle<A> implements Stream<A> {\n  readonly period: number;\n  readonly source: Stream<A>;\n\n  constructor(period: number, source: Stream<A>) {\n    this.period = period\n    this.source = source\n  }\n\n  run(sink: Sink<A>, scheduler: Scheduler): Disposable {\n    return this.source.run(new ThrottleSink(this.period, sink), scheduler)\n  }\n}\n\nclass ThrottleSink<A> extends Pipe<A, A> implements Sink<A> {\n  private time: Time\n  private readonly period: number;\n\n  constructor(period: number, sink: Sink<A>) {\n    super(sink)\n    this.time = 0\n    this.period = period\n  }\n\n  event(t: Time, x: A): void {\n    if (t >= this.time) {\n      this.time = t + this.period\n      this.sink.event(t, x)\n    }\n  }\n}\n/**\n * Wait for a burst of events to subside and emit only the last event in the burst\n * @param period events occuring more frequently than this will be suppressed\n * @param stream stream to debounce\n * @returns new debounced stream\n */\nexport const debounce = <A>(period: number, stream: Stream<A>): Stream<A> =>\n  isCanonicalEmpty(stream) ? empty()\n    : new Debounce(period, stream)\n\nclass Debounce<A> implements Stream<A> {\n  private readonly dt: number;\n  private readonly source: Stream<A>\n\n  constructor(dt: number, source: Stream<A>) {\n    this.dt = dt\n    this.source = source\n  }\n\n  run(sink: Sink<A>, scheduler: Scheduler): Disposable {\n    return new DebounceSink(this.dt, this.source, sink, scheduler)\n  }\n}\n\nclass DebounceSink<A> implements Sink<A>, Disposable {\n  private readonly dt: number;\n  private readonly sink: Sink<A>;\n  private readonly scheduler: Scheduler\n  private value: A | undefined;\n  private timer: ScheduledTask | null\n  private disposable: Disposable\n\n  constructor(dt: number, source: Stream<A>, sink: Sink<A>, scheduler: Scheduler) {\n    this.dt = dt\n    this.sink = sink\n    this.scheduler = scheduler\n    this.timer = null\n\n    this.disposable = source.run(this, scheduler)\n  }\n\n  event(_t: Time, x: A): void {\n    this.clearTimer()\n    this.value = x\n    this.timer = delay(this.dt, new DebounceTask(this, x), this.scheduler)\n  }\n\n  handleEventFromTask(t: Time, x: A): void {\n    this.clearTimer()\n    this.sink.event(t, x)\n  }\n\n  end(t: Time): void {\n    if (this.clearTimer()) {\n      // TODO: value should be boxed to avoid ! bang\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      this.sink.event(t, this.value!)\n      this.value = undefined\n    }\n    this.sink.end(t)\n  }\n\n  error(t: Time, x: Error): void {\n    this.clearTimer()\n    this.sink.error(t, x)\n  }\n\n  dispose(): void {\n    this.clearTimer()\n    this.disposable.dispose()\n  }\n\n  private clearTimer(): boolean {\n    if (this.timer === null) {\n      return false\n    }\n    this.timer.dispose()\n    this.timer = null\n    return true\n  }\n}\n\nclass DebounceTask<A> implements Task {\n  private readonly sink: DebounceSink<A>;\n  private readonly value: A;\n\n  constructor(sink: DebounceSink<A>, value: A) {\n    this.sink = sink\n    this.value = value\n  }\n\n  run(t: Time): void {\n    this.sink.handleEventFromTask(t, this.value)\n  }\n\n  error(t: Time, e: Error): void {\n    this.sink.error(t, e)\n  }\n\n  dispose(): void {}\n}\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nimport fatal from '../fatalError'\nimport { now } from '../source/now'\nimport { empty, isCanonicalEmpty } from '../source/empty'\nimport { currentTime } from '@most/scheduler'\nimport { Stream, Sink, Scheduler, Time, Disposable } from '@most/types'\n\n/**\n * Turn a Stream<Promise<T>> into Stream<T> by awaiting each promise.\n * Event order is preserved. The stream will fail if any promise rejects.\n */\nexport const awaitPromises = <A>(stream: Stream<Promise<A>>): Stream<A> =>\n  isCanonicalEmpty(stream) ? empty() : new Await(stream)\n\n/**\n * Create a stream containing only the promise's fulfillment\n * value at the time it fulfills.\n * @param promise\n * @return stream containing promise's fulfillment value.\n *  If the promise rejects, the stream will error\n */\nexport const fromPromise = <A>(promise: Promise<A>): Stream<A> => awaitPromises(now(promise))\n\nclass Await<A> implements Stream<A> {\n  private readonly source: Stream<Promise<A>>\n\n  constructor(source: Stream<Promise<A>>) {\n    this.source = source\n  }\n\n  run(sink: Sink<A>, scheduler: Scheduler): Disposable {\n    return this.source.run(new AwaitSink(sink, scheduler), scheduler)\n  }\n}\n\nclass AwaitSink<A> implements Sink<Promise<A>> {\n  private readonly sink: Sink<A>;\n  private readonly scheduler: Scheduler;\n  private queue: Promise<unknown>;\n\n  constructor(sink: Sink<A>, scheduler: Scheduler) {\n    this.sink = sink\n    this.scheduler = scheduler\n    this.queue = Promise.resolve()\n  }\n\n  event(_t: Time, promise: Promise<A>): void {\n    this.queue = this.queue.then(() => this.handlePromise(promise))\n      .catch(this.errorBound)\n  }\n\n  end(): void {\n    this.queue = this.queue.then(this.endBound)\n      .catch(this.errorBound)\n  }\n\n  error(_t: Time, e: Error): void {\n    // Don't resolve error values, propagate directly\n    this.queue = this.queue.then(() => this.errorBound(e))\n      .catch(fatal)\n  }\n\n  private handlePromise(promise: Promise<A>): Promise<void> {\n    return promise.then(this.eventBound)\n  }\n\n  // Pre-create closures, to avoid creating them per event\n  private eventBound = (x: A): void => this.sink.event(currentTime(this.scheduler), x)\n  private endBound = (): void => this.sink.end(currentTime(this.scheduler))\n  private errorBound = (e: Error): void => this.sink.error(currentTime(this.scheduler), e)\n}\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\nimport { Sink, Time } from '@most/types'\n\nexport default class SafeSink<A> implements Sink<A> {\n  private readonly sink: Sink<A>\n  private active: boolean;\n\n  constructor(sink: Sink<A>) {\n    this.sink = sink\n    this.active = true\n  }\n\n  event(t: Time, x: A): void {\n    if (!this.active) {\n      return\n    }\n    this.sink.event(t, x)\n  }\n\n  end(t: Time): void{\n    if (!this.active) {\n      return\n    }\n    this.disable()\n    this.sink.end(t)\n  }\n\n  error(t: Time, e: Error): void{\n    this.disable()\n    this.sink.error(t, e)\n  }\n\n  disable(): Sink<A> {\n    this.active = false\n    return this.sink\n  }\n}\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nimport { Time, Sink } from '@most/types'\n\nexport function tryEvent <A>(t: Time, x: A, sink: Sink<A>): void {\n  try {\n    sink.event(t, x)\n  } catch (e) {\n    sink.error(t, e)\n  }\n}\n\nexport function tryEnd(t: Time, sink: Sink<unknown>): void {\n  try {\n    sink.end(t)\n  } catch (e) {\n    sink.error(t, e)\n  }\n}\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nimport SafeSink from '../sink/SafeSink'\nimport { tryDispose } from '@most/disposable'\nimport { asap } from '@most/scheduler'\nimport { tryEvent, tryEnd } from '../source/tryEvent'\nimport { empty, isCanonicalEmpty } from '../source/empty'\nimport { propagateErrorTask } from '../scheduler/PropagateTask'\nimport { run } from '../run'\nimport { withLocalTime } from './withLocalTime'\nimport { Stream, Sink, Scheduler, Disposable, Time } from '@most/types'\n\n/**\n * If stream encounters an error, recover and continue with items from stream\n * returned by f.\n * @param f which returns a new stream\n * @param stream\n * @returns new stream which will recover from an error by calling f\n */\nexport const recoverWith = <A, E extends Error, B = A>(f: (error: E) => Stream<B>, stream: Stream<A>): Stream<A | B> =>\n  isCanonicalEmpty(stream) ? empty()\n    : new RecoverWith(f, stream)\n\n/**\n * Create a stream containing only an error\n * @param e error value, preferably an Error or Error subtype\n * @returns new stream containing only an error\n */\nexport const throwError = (e: Error): Stream<never> =>\n  new ErrorStream(e)\n\nclass ErrorStream implements Stream<never> {\n  private readonly value: Error;\n\n  constructor(e: Error) {\n    this.value = e\n  }\n\n  run(sink: Sink<never>, scheduler: Scheduler): Disposable {\n    return asap(propagateErrorTask(this.value, sink), scheduler)\n  }\n}\n\nclass RecoverWith<A, E extends Error, B> implements Stream<A | B> {\n  private readonly f: (error: E) => Stream<B>;\n  private readonly source: Stream<A>;\n\n  constructor(f: (error: E) => Stream<B>, source: Stream<A>) {\n    this.f = f\n    this.source = source\n  }\n\n  run(sink: Sink<A>, scheduler: Scheduler): Disposable {\n    return new RecoverWithSink(this.f, this.source, sink, scheduler)\n  }\n}\n\nclass RecoverWithSink<A, E extends Error, B> implements Sink<A>, Disposable {\n  private readonly f: (error: E) => Stream<B>\n  private readonly sink: SafeSink<A>\n  private readonly scheduler: Scheduler\n  private disposable: Disposable\n\n  constructor(f: (error: E) => Stream<B>, source: Stream<A>, sink: Sink<A | B>, scheduler: Scheduler) {\n    this.f = f\n    this.sink = new SafeSink(sink)\n    this.scheduler = scheduler\n    this.disposable = source.run(this, scheduler)\n  }\n\n  event(t: Time, x: A): void {\n    tryEvent(t, x, this.sink)\n  }\n\n  end(t: Time): void {\n    tryEnd(t, this.sink)\n  }\n\n  error(t: Time, e: E): void {\n    const nextSink = this.sink.disable()\n\n    tryDispose(t, this.disposable, this.sink)\n\n    this._startNext(t, e, nextSink)\n  }\n\n  private _startNext(t: Time, x: E, sink: Sink<A>): void {\n    try {\n      this.disposable = this._continue(this.f, t, x, sink)\n    } catch (e) {\n      sink.error(t, e)\n    }\n  }\n\n  private _continue(f: (error: E) => Stream<B>, t: Time, x: E, sink: Sink<A | B>): Disposable {\n    return run(sink, this.scheduler, withLocalTime(t, f(x)))\n  }\n\n  dispose(): void {\n    return this.disposable.dispose()\n  }\n}\n", "import { append, findIndex, remove } from '@most/prelude'\nimport { disposeNone, disposeOnce } from '@most/disposable'\nimport { tryEnd, tryEvent } from '../source/tryEvent'\nimport { isCanonicalEmpty } from '../source/empty'\nimport { Stream, Scheduler, Sink, Disposable, Time } from '@most/types'\n\nexport const multicast = <A>(stream: Stream<A>): Stream<A> =>\n  stream instanceof Multicast || isCanonicalEmpty(stream)\n    ? stream\n    : new Multicast(stream)\n\nclass Multicast<A> implements Stream<A> {\n  private readonly source: Stream<A>;\n  constructor(source: Stream<A>) {\n    this.source = new MulticastSource(source)\n  }\n  run(sink: Sink<A>, scheduler: Scheduler): Disposable {\n    return this.source.run(sink, scheduler)\n  }\n}\n\nexport class MulticastSource<A> implements Stream<A>, Disposable {\n  private readonly source: Stream<A>;\n  private sinks: Sink<A>[];\n  private disposable: Disposable;\n\n  constructor(source: Stream<A>) {\n    this.source = source\n    this.sinks = []\n    this.disposable = disposeNone()\n  }\n\n  run(sink: Sink<A>, scheduler: Scheduler): Disposable {\n    const n = this.add(sink)\n    if (n === 1) {\n      this.disposable = this.source.run(this, scheduler)\n    }\n    return disposeOnce(new MulticastDisposable(this, sink))\n  }\n\n  dispose(): void {\n    const disposable = this.disposable\n    this.disposable = disposeNone()\n    return disposable.dispose()\n  }\n\n  add(sink: Sink<A>): number {\n    this.sinks = append(sink, this.sinks)\n    return this.sinks.length\n  }\n\n  remove(sink: Sink<A>): number {\n    const i = findIndex(sink, this.sinks)\n    // istanbul ignore next\n    if (i >= 0) {\n      this.sinks = remove(i, this.sinks)\n    }\n\n    return this.sinks.length\n  }\n\n  event(time: Time, value: A): void {\n    const s = this.sinks\n    if (s.length === 1) {\n      return s[0].event(time, value)\n    }\n    for (let i = 0; i < s.length; ++i) {\n      tryEvent(time, value, s[i])\n    }\n  }\n\n  end(time: Time): void {\n    const s = this.sinks\n    for (let i = 0; i < s.length; ++i) {\n      tryEnd(time, s[i])\n    }\n  }\n\n  error(time: Time, err: Error): void {\n    const s = this.sinks\n    for (let i = 0; i < s.length; ++i) {\n      s[i].error(time, err)\n    }\n  }\n}\n\nexport class MulticastDisposable<A> implements Disposable {\n  private readonly source: MulticastSource<A>\n  private readonly sink: Sink<A>\n\n  constructor(source: MulticastSource<A>, sink: Sink<A>) {\n    this.source = source\n    this.sink = sink\n  }\n\n  dispose(): void {\n    if (this.source.remove(this.sink) === 0) {\n      this.source.dispose()\n    }\n  }\n}\n", "/** @license MIT License (c) copyright 2016 original author or authors */\n/* eslint-disable import/first */\nimport { curry2, curry3, Curried2 } from '@most/prelude'\n\nexport { empty } from './source/empty'\nexport { never } from './source/never'\nexport { now } from './source/now'\nexport { at } from './source/at'\n\nexport { periodic } from './source/periodic'\n\nexport { newStream } from './source/newStream'\n\n// -----------------------------------------------------------------------\n// Observing\n\nexport { runEffects } from './runEffects'\nimport { run as _run } from './run'\n\ninterface Run {\n  <A> (sink: Sink<A>, scheduler: Scheduler, s: Stream<A>): Disposable\n  <A> (sink: Sink<A>, scheduler: Scheduler): (s: Stream<A>) => Disposable\n  <A> (sink: Sink<A>): Curried2<Scheduler, Stream<A>, Disposable>\n}\nexport const run: Run = curry3(_run)\n\n// -------------------------------------------------------\n\nimport { withLocalTime as _withLocalTime } from './combinator/withLocalTime'\n\ninterface WithLocalTime {\n  <A>(origin: Time, s: Stream<A>): Stream<A>\n  <A>(origin: Time): (s: Stream<A>) => Stream<A>\n}\nexport const withLocalTime: WithLocalTime = curry2(_withLocalTime)\n\n// -------------------------------------------------------\n\nimport { loop as _loop, SeedValue } from './combinator/loop'\n\ninterface Loop {\n  <A, B, S>(f: (seed: S, a: A) => SeedValue<S, B>, seed: S, s: Stream<A>): Stream<B>\n  <A, B, S>(f: (seed: S, a: A) => SeedValue<S, B>, seed: S): (s: Stream<A>) => Stream<B>\n  <A, B, S>(f: (seed: S, a: A) => SeedValue<S, B>): Curried2<S, Stream<A>, Stream<B>>\n}\nexport const loop: Loop = curry3(_loop)\n\n// -------------------------------------------------------\n\nimport { scan as _scan } from './combinator/scan'\n\ninterface Scan {\n  <A, B>(f: (b: B, a: A) => B, b: B, s: Stream<A>): Stream<B>\n  <A, B>(f: (b: B, a: A) => B, b: B): (s: Stream<A>) => Stream<B>\n  <A, B>(f: (b: B, a: A) => B): Curried2<B, Stream<A>, Stream<B>>\n}\nexport const scan: Scan = curry3(_scan)\n\n// -----------------------------------------------------------------------\n// Extending\n\nimport { startWith as _startWith } from './combinator/startWith'\n\ninterface StartWith {\n  <A>(value: A, stream: Stream<A>): Stream<A>\n  <A>(value: A): (stream: Stream<A>) => Stream<A>\n}\nexport const startWith: StartWith = curry2(_startWith)\n\n// -----------------------------------------------------------------------\n// Transforming\n\nimport { map as _map, constant as _constant, tap as _tap } from './combinator/transform'\nimport { ap as _ap } from './combinator/applicative'\n\ninterface Map {\n  <A, B>(f: (a: A) => B, s: Stream<A>): Stream<B>\n  <A, B>(f: (a: A) => B): (s: Stream<A>) => Stream<B>\n}\nexport const map: Map = curry2(_map)\ninterface Constant {\n  <A, B>(b: B, s: Stream<A>): Stream<B>\n  <A, B>(b: B): (s: Stream<A>) => Stream<B>\n}\nexport const constant: Constant = curry2(_constant)\ninterface Tap {\n  <A>(f: (a: A) => any, s: Stream<A>): Stream<A>\n  <A>(f: (a: A) => any): (s: Stream<A>) => Stream<A>\n}\nexport const tap: Tap = curry2(_tap)\ninterface Ap {\n  <A, B>(streamofFunctions: Stream<(a: A) => B>, streamOfValues: Stream<A>): Stream<B>\n  <A, B>(streamofFunctions: Stream<(a: A) => B>): (streamOfValues: Stream<A>) => Stream<B>\n}\nexport const ap: Ap = curry2(_ap)\n\n// -----------------------------------------------------------------------\n// FlatMapping\n\nimport { chain as _chain, join } from './combinator/chain'\ninterface Chain {\n  <A, B>(f: (value: A) => Stream<B>, stream: Stream<A>): Stream<B>\n  <A, B>(f: (value: A) => Stream<B>): (stream: Stream<A>) => Stream<B>\n}\nexport const chain: Chain = curry2(_chain)\nexport { join }\n\nimport { continueWith as _continueWith } from './combinator/continueWith'\ninterface ContinueWith {\n  <A, B = A>(f: () => Stream<B>, s: Stream<A>): Stream<A | B>\n  <A, B = A>(f: () => Stream<B>): (s: Stream<A>) => Stream<A | B>\n}\nexport const continueWith: ContinueWith = curry2(_continueWith)\n\nimport { concatMap as _concatMap } from './combinator/concatMap'\ninterface ConcatMap {\n  <A, B>(f: (a: A) => Stream<B>, stream: Stream<A>): Stream<B>\n  <A, B>(f: (a: A) => Stream<B>): (stream: Stream<A>) => Stream<B>\n}\nexport const concatMap: ConcatMap = curry2(_concatMap)\n\n// -----------------------------------------------------------------------\n// Concurrent merging\n\nimport { mergeConcurrently as _mergeConcurrently, mergeMapConcurrently as _mergeMapConcurrently } from './combinator/mergeConcurrently'\n\ninterface MergeConcurrently {\n  <A>(concurrency: number, s: Stream<Stream<A>>): Stream<A>\n  <A>(concurrency: number): (s: Stream<Stream<A>>) => Stream<A>\n}\nexport const mergeConcurrently: MergeConcurrently = curry2<number, Stream<Stream<unknown>>, Stream<unknown>>(_mergeConcurrently)\ninterface MergeMapConcurrently {\n  <A, B>(f: (a: A) => Stream<B>, concurrency: number, s: Stream<A>): Stream<B>\n  <A, B>(f: (a: A) => Stream<B>, concurrency: number): (s: Stream<A>) => Stream<B>\n  <A, B>(f: (a: A) => Stream<B>): Curried2<number, Stream<A>, Stream<B>>\n}\nexport const mergeMapConcurrently: MergeMapConcurrently = curry3(_mergeMapConcurrently)\n\n// -----------------------------------------------------------------------\n// Merging\n\nimport { merge as _merge, mergeArray } from './combinator/merge'\n\ninterface Merge {\n  <A, B>(s1: Stream<A>, s2: Stream<B>): Stream<A | B>\n  <A, B>(s1: Stream<A>): (s2: Stream<B>) => Stream<A | B>\n}\nexport const merge: Merge = curry2(_merge)\nexport { mergeArray }\n\n// -----------------------------------------------------------------------\n// Combining\n\nimport { combine as _combine, combineArray as _combineArray } from './combinator/combine'\n\ninterface Combine {\n  <A, B, R>(fn: (a: A, b: B) => R, a: Stream<A>, b: Stream<B>): Stream<R>\n  <A, B, R>(fn: (a: A, b: B) => R, a: Stream<A>): (b: Stream<B>) => Stream<R>\n  <A, B, R>(fn: (a: A, b: B) => R): Curried2<Stream<A>, Stream<B>, Stream<R>>\n}\nexport const combine: Combine = curry3(_combine)\ninterface CombineArray {\n  <Args extends unknown[], R>(fn: (...args: Args) => R, streams: ToStreamsArray<Args>): Stream<R>\n  <Args extends unknown[], R>(fn: (...args: Args) => R): (streams: ToStreamsArray<Args>) => Stream<R>\n}\nexport const combineArray: CombineArray = curry2(_combineArray as any) as any\n\n// -----------------------------------------------------------------------\n// Sampling\n\nimport { sample as _sample, snapshot as _snapshot } from './combinator/snapshot'\n\ninterface Sample {\n  <A, B>(values: Stream<A>, sampler: Stream<B>): Stream<A>\n  <A, B>(values: Stream<A>): (sampler: Stream<B>) => Stream<A>\n}\nexport const sample: Sample = curry2(_sample)\ninterface Snapshot {\n  <A, B, C>(f: (a: A, b: B) => C, values: Stream<A>, sampler: Stream<B>): Stream<C>\n  <A, B, C>(f: (a: A, b: B) => C, values: Stream<A>): (sampler: Stream<B>) => Stream<C>\n  <A, B, C>(f: (a: A, b: B) => C): Curried2<Stream<A>, Stream<B>, Stream<C>>\n}\nexport const snapshot: Snapshot = curry3(_snapshot)\n\n// -----------------------------------------------------------------------\n// Zipping\n\nimport { zipItems as _zipItems, withItems as _withItems } from './combinator/zipItems'\ninterface ZipItems {\n  <A, B, C> (f: (a: A, b: B) => C, a: Array<A>, s: Stream<B>): Stream<C>\n  <A, B, C> (f: (a: A, b: B) => C, a: Array<A>): (s: Stream<B>) => Stream<C>\n  <A, B, C> (f: (a: A, b: B) => C): Curried2<Array<A>, Stream<B>, Stream<C>>\n}\nexport const zipItems: ZipItems = curry3(_zipItems)\ninterface WithItems {\n  <A>(a: Array<A>, s: Stream<unknown>): Stream<A>\n  <A>(a: Array<A>): (s: Stream<unknown>) => Stream<A>\n}\nexport const withItems: WithItems = curry2(_withItems)\n\nimport { zip as _zip, zipArray as _zipArray } from './combinator/zip'\ninterface Zip {\n  <A, B, R>(fn: (a: A, b: B) => R, a: Stream<A>, b: Stream<B>): Stream<R>\n  <A, B, R>(fn: (a: A, b: B) => R, a: Stream<A>): (b: Stream<B>) => Stream<R>\n  <A, B, R>(fn: (a: A, b: B) => R): Curried2<Stream<A>, Stream<B>, Stream<R>>\n}\nexport const zip: Zip = curry3(_zip)\ninterface ZipArray {\n  <Args extends unknown[], R>(fn: (...args: Args) => R, streams: ToStreamsArray<Args>): Stream<R>\n  <Args extends unknown[], R>(fn: (...args: Args) => R): (streams: ToStreamsArray<Args>) => Stream<R>\n}\nexport const zipArray: ZipArray = curry2(_zipArray as any) as any\n\n// -----------------------------------------------------------------------\n// Switching\n\nexport { switchLatest } from './combinator/switch'\n\n// -----------------------------------------------------------------------\n// Filtering\n\nimport { filter as _filter, skipRepeats, skipRepeatsWith as _skipRepeatsWith } from './combinator/filter'\n\ninterface Filter {\n  <A, B extends A>(p: (a: A) => a is B, s: Stream<A>): Stream<B>\n  <A>(p: (a: A) => boolean, s: Stream<A>): Stream<A>\n  <A, B extends A>(p: (a: A) => a is B): (s: Stream<A>) => Stream<B>\n  <A>(p: (a: A) => boolean): (s: Stream<A>) => Stream<A>\n}\nexport const filter: Filter = curry2(_filter)\nexport { skipRepeats }\ninterface ShipRepeatsWith {\n  <A>(eq: (a1: A, a2: A) => boolean, s: Stream<A>): Stream<A>\n  <A>(eq: (a1: A, a2: A) => boolean): (s: Stream<A>) => Stream<A>\n}\nexport const skipRepeatsWith: ShipRepeatsWith = curry2(_skipRepeatsWith)\n\n// -----------------------------------------------------------------------\n// Slicing\n\nimport { take as _take, skip as _skip, slice as _slice, takeWhile as _takeWhile, skipWhile as _skipWhile, skipAfter as _skipAfter } from './combinator/slice'\n\ninterface Take {\n  <A>(n: number, s: Stream<A>): Stream<A>\n  <A>(n: number): (s: Stream<A>) => Stream<A>\n}\nexport const take: Take = curry2(_take)\ninterface Skip {\n  <A>(n: number, s: Stream<A>): Stream<A>\n  <A>(n: number): (s: Stream<A>) => Stream<A>\n}\nexport const skip: Skip = curry2(_skip)\ninterface Slice {\n  <A>(start: number, end: number, s: Stream<A>): Stream<A>\n  <A>(start: number, end: number): (s: Stream<A>) => Stream<A>\n  <A>(start: number): Curried2<number, Stream<A>, Stream<A>>\n}\nexport const slice: Slice = curry3(_slice)\ninterface TakeWhile {\n  <A>(p: (a: A) => boolean, s: Stream<A>): Stream<A>\n  <A>(p: (a: A) => boolean): (s: Stream<A>) => Stream<A>\n}\nexport const takeWhile: TakeWhile = curry2(_takeWhile)\ninterface SkipWhile {\n  <A>(p: (a: A) => boolean, s: Stream<A>): Stream<A>\n  <A>(p: (a: A) => boolean): (s: Stream<A>) => Stream<A>\n}\nexport const skipWhile: SkipWhile = curry2(_skipWhile)\ninterface SkipAfter {\n  <A>(p: (a: A) => boolean, s: Stream<A>): Stream<A>\n  <A>(p: (a: A) => boolean): (s: Stream<A>) => Stream<A>\n}\nexport const skipAfter: SkipAfter = curry2(_skipAfter)\n\n// -----------------------------------------------------------------------\n// Time slicing\n\nimport { until as _until, since as _since, during as _during } from './combinator/timeslice'\n\ninterface Until {\n  <A>(signal: Stream<any>, s: Stream<A>): Stream<A>\n  <A>(signal: Stream<any>): (s: Stream<A>) => Stream<A>\n}\nexport const until: Until = curry2(_until)\ninterface Since {\n  <A>(signal: Stream<any>, s: Stream<A>): Stream<A>\n  <A>(signal: Stream<any>): (s: Stream<A>) => Stream<A>\n}\nexport const since: Since = curry2(_since)\ninterface During {\n  <A>(timeWindow: Stream<Stream<any>>, s: Stream<A>): Stream<A>\n  <A>(timeWindow: Stream<Stream<any>>): (s: Stream<A>) => Stream<A>\n}\nexport const during: During = curry2(_during)\n\n// -----------------------------------------------------------------------\n// Delaying\n\nimport { delay as _delay } from './combinator/delay'\n\ninterface Delay {\n  <A>(dt: number, s: Stream<A>): Stream<A>\n  <A>(dt: number): (s: Stream<A>) => Stream<A>\n}\nexport const delay: Delay = curry2(_delay)\n\n// -----------------------------------------------------------------------\n// Rate limiting\n\nimport { throttle as _throttle, debounce as _debounce } from './combinator/limit'\n\ninterface Throttle {\n  <A>(period: number, s: Stream<A>): Stream<A>\n  <A>(period: number): (s: Stream<A>) => Stream<A>\n}\nexport const throttle: Throttle = curry2(_throttle)\ninterface Debounce {\n  <A>(period: number, s: Stream<A>): Stream<A>\n  <A>(period: number): (s: Stream<A>) => Stream<A>\n}\nexport const debounce: Debounce = curry2(_debounce)\n\n// -----------------------------------------------------------------------\n// Awaiting Promises\n\nexport { fromPromise, awaitPromises } from './combinator/promises'\n\n// -----------------------------------------------------------------------\n// Error handling\n\nimport { recoverWith as _recoverWith, throwError } from './combinator/errors'\n\ninterface RecoverWith {\n  <A, E extends Error, B = A>(p: (error: E) => Stream<B>, s: Stream<A>): Stream<A | B>\n  <A, E extends Error, B = A>(p: (error: E) => Stream<B>): (s: Stream<A>) => Stream<A | B>\n}\nexport const recoverWith: RecoverWith = curry2(_recoverWith)\nexport { throwError }\n\n// -----------------------------------------------------------------------\n// Multicasting\n\nexport { multicast, MulticastSource } from './combinator/multicast'\n\n// ----------------------------------------------------------------------\nimport {\n  propagateTask as _propagateTask,\n  propagateEventTask as _propagateEventTask,\n  propagateErrorTask as _propagateErrorTask,\n  propagateEndTask,\n  PropagateTaskRun,\n  PropagateTask as PropagateTaskResult\n} from './scheduler/PropagateTask'\nimport { Stream, Sink, Scheduler, Disposable, Time } from '@most/types'\nimport { ToStreamsArray } from './combinator/variadic'\n\ninterface PropagateTask {\n  <A>(run: PropagateTaskRun<A>, value: A, sink: Sink<A>): PropagateTaskResult\n  <A>(run: PropagateTaskRun<A>, value: A): (sink: Sink<A>) => PropagateTaskResult\n  <A>(run: PropagateTaskRun<A>): Curried2<A, Sink<A>, PropagateTaskResult>\n}\nexport const propagateTask: PropagateTask = curry3(_propagateTask)\ninterface PropagateEventTask {\n  <T>(value: T, sink: Sink<T>): PropagateTaskResult\n  <T>(value: T): (sink: Sink<T>) => PropagateTaskResult\n}\nexport const propagateEventTask: PropagateEventTask = curry2(_propagateEventTask)\nexport const propagateErrorTask: Curried2<Error, Sink<unknown>, PropagateTaskResult> = curry2(_propagateErrorTask)\nexport { propagateEndTask }\n", null, null, null, null, null, null, "import { constant, map, multicast, join, take } from '@most/core'\nimport { propagateEventTask } from '@most/core'\nimport { Time } from '@most/types'\nimport { Stream, Sink, Scheduler, Disposable } from '@most/types'\nimport { curry } from '@typed/curry'\n\nclass Grid implements Stream<void> {\n  private readonly period: Time\n  private readonly phase: Time\n\n  constructor(period: Time, phase: Time = 0) {\n    this.period = period\n    this.phase = phase\n  }\n\n  run(sink: Sink<void>, scheduler: Scheduler): Disposable {\n    const delay = this.period - (scheduler.currentTime() % this.period) + (this.phase % this.period)\n    return scheduler.scheduleTask(0, delay, this.period, propagateEventTask(undefined, sink))\n  }\n}\n\n/**\n * Create a stream of events that occur at a regular period on a grid\n * @param {Time} period periodicity of events\n * @returns {Stream} new stream of periodic events, the event value is undefined\n */\nexport const grid = (period: Time, phase: Time = 0): Stream<void> => new Grid(period, phase)\n\n/**\n * Produce a stream that emits a given value simultaneously with the next event in a given stream.\n * @param {Stream} alignment$ the stream to align to\n * @param {any} value the value to emit\n * @returns {Stream} a stream that emits the given value upon the next event in the alignment stream\n */\nexport const aligned = curry((alignment$: Stream<any>, value: any) => constant(value, take(1, alignment$)))\n\nexport const quantize = curry((period: Time, $: Stream<any>) => {\n  const grid$ = multicast(grid(period))\n  return join(\n    //\n    map(aligned(grid$), $),\n  )\n})\n", "import { periodic, constant, until, at, slice, withLocalTime, mergeArray, now, join } from '@most/core';\nimport { Time, Stream } from '@most/types'\nimport { pipe } from 'fp-ts/lib/function'\nimport { curry } from '@typed/curry'\n\nconst phaseWithinCycle = (clipStart: Time, clipEnd: Time, phase: Time) => {\n  const period: Time = clipEnd - clipStart\n  return clipStart + (phase % period) // get the equivalent starting point within specified loop region\n}\n\nexport const beginning = curry((A: Time, B: Time, phase: Time, source$: Stream<any>) => {\n  phase = phaseWithinCycle(A, B, phase)\n  return withLocalTime(phase, slice(phase, B, source$))\n})\n\nexport const ending = curry((A: Time, B: Time, phase: Time, source$: Stream<any>) => {\n  phase = phaseWithinCycle(A, B, phase)\n  return withLocalTime(A, slice(A, phase, source$))\n})\n\n/**\n* Create a cyclic clip stream from a given source stream, centered around the time given by `phase`.\n* @summary If the description is long, write your summary here. Otherwise, feel free to remove this.\n* @param {Time} clipStart -\n* @param {Time} clipEnd -\n* @param {Time} phase -\n* @param {Stream<T>} source$ -\n* @return {Stream<T>} Brief description of the returning value here.\n*/\n\nexport const clipPeriodic = curry((A: Time, B: Time, phase: Time, source$: Stream<any>) => {\n  return join(mergeArray([\n    now(beginning(A, B, phase, source$)),\n    at(B, ending(A, B, phase, source$)),\n  ]))\n})\n\nexport const cycle = curry((A: Time, B: Time, phase: Time, $: Stream<any>) => {\n  return pipe(\n    //\n    periodic(B - A),\n    constant(clipPeriodic(A, B, phase, $)),\n  )\n})\n\nexport const endlessCycle = curry((A: Time, B: Time, phase: Time, $: Stream<any>) => join(cycle(A, B, phase, $)))\n\nexport const pickup = curry((A:Time, B: Time, countdown: Time, $: Stream<any>) =>\n  cycle(A, B, B - countdown % (B-A), $))\n\nexport default curry((duration: Time, $: Stream<any>) =>\n  pipe(\n    //\n    periodic(duration),\n    constant(until(at(duration, null), $)),\n  ),\n)\n", "import { Stream } from '@most/types'\nimport { filter, tap } from '@most/core'\n\nexport const tapConsole = (msg: any) => tap((x) => console.log(msg, x)); // eslint-disable-line\n\nexport const isOn = ($: Stream<any>) => filter((l: any) => l, $)\nexport const isOff = ($: Stream<any>) => filter((l: any) => !l, $)\n", "import { curry } from '@typed/curry'\nimport { Stream } from '@most/types'\nimport { constant, empty, map, take, until, filter, merge, skipRepeats, mergeArray, multicast } from '@most/core'\nimport { isOff, isOn } from './util';\n\ninterface SpigotSpec {\n  on$: Stream<Boolean>\n  off$?: Stream<Boolean>\n  fx?: ($: Stream<any>) => any\n}\n\nexport const spout = curry((flow$: Stream<any>, latch$: Stream<Boolean>) => {\n  const trimmedFlow$ = until(isOff(latch$), flow$)\n  return constant(trimmedFlow$, isOn(latch$))\n})\n\nexport const spigot = curry(({ on$, off$, fx }: SpigotSpec, latch$: Stream<any>) => {\n  on$ = on$ || empty()\n  off$ = off$ || empty()\n\n  const output = merge(spout(on$, isOn(latch$)), spout(off$, isOff(latch$)))\n  return fx ? map(fx, output) : output\n})\n\nexport type routeKey = string\n\nexport const router = curry((routes: { route: Stream<any> }, control$: Stream<routeKey | Set<routeKey>>) => {\n  control$ = multicast(skipRepeats(control$))\n  const mergedFlow$ = mergeArray(\n    Object.entries(routes).map(([routeKey, flow$]) =>\n      spout(\n        //\n        flow$,\n        isOn(filter((controlKey) => controlKey === routeKey || (controlKey as Set<routeKey>).has(routeKey), control$)),\n      ),\n    ),\n  )\n  const finished$ = take(\n    1,\n    filter((x) => x === null, control$),\n  )\n  return until(finished$, mergedFlow$)\n})\n"],
  "mappings": "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",
  "names": []
}
